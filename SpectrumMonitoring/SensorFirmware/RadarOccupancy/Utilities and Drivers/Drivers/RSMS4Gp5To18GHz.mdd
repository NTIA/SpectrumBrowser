<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>C:\Program Files\MATLAB\R2009b\toolbox\instrument\instrument\drivers\RSMS4G_5To18GHzPresel.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Switch</InstrumentType>
   <InstrumentManufacturer>Sixnet</InstrumentManufacturer>
   <InstrumentModel>EtherTrak</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
set(interface, 'OutputBufferSize', 256);
set(interface, 'InputBufferSize', 256);
set(interface, 'ByteOrder', 'bigEndian');
set(interface, 'Terminator', {'CR/LF','CR/LF'});
fclose(interface);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>iGenAtten</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% read appropriate bits from Modbus Device
[AttenBits, Success, ~] = ModbusDigitalRead(interfaceObj, 1, 6, 3);

if Success
  % Convert returned bits to an attenuation value
  propertyValue = bitflip(uint8(bin2dec(num2str(AttenBits))),3)*10;
else % there was a problem return empty vector
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% Convert the input attenuation value to a bit vector for the modbus
% command
temp = dec2bin(bitflip(uint8(propertyValue/10),3),3);
for ii = 1:length(temp)
  AttenBits(ii) = str2double(temp(ii));
end


% write the Attenuation bits to the modbus device
ModbusDigitalWrite(interfaceObj, 1, 6, AttenBits);

</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>10.0</Value>
                     <Value>20.0</Value>
                     <Value>30.0</Value>
                     <Value>40.0</Value>
                     <Value>50.0</Value>
                     <Value>60.0</Value>
                     <Value>70.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>  Sets the attenuation to the value (in dB) specified by user or queries the current attenuation. if an error occurs during a query then the empty set is returned.
</Description>
            </Property>
            <Property>
               <Name>iGenAttenChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% read appropriate bits from Modbus Device
[AttenBits, Success, ErrMsg] = ModbusDigitalRead(interfaceObj, 1, 6, 3);

if Success
  % Convert returned bits to an attenuation value
  propertyValue = bitflip(uint8(bin2dec(num2str(AttenBits))),3)*10;
else % there was a problem return empty vector
  propertyValue = [];
  error('Presel:Property:Atten:ModbusQueryErr', ErrMsg);
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% Convert the input attenuation value to a bit vector for the modbus
% command
temp = dec2bin(bitflip(uint8(propertyValue/10),3),3);
for ii = 1:length(temp)
  AttenBits(ii) = str2double(temp(ii));
end


% write the Attenuation bits to the modbus device
[Success, ErrMsg] = ModbusDigitalWrite(interfaceObj, 1, 6, AttenBits);

if Success
  % check the setting
  SetAtten = get(obj, 'iGenAtten');
  if SetAtten ~= propertyValue
    error('Presel:Property:Atten:SettingIncorrect',...
      'The preselector attenuation is not set as requested');
  end
else % there was a modbus problem
  error('Presel:Property:Atten:ModbusWriteErr', ErrMsg);
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>10.0</Value>
                     <Value>20.0</Value>
                     <Value>30.0</Value>
                     <Value>40.0</Value>
                     <Value>50.0</Value>
                     <Value>60.0</Value>
                     <Value>70.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the attenuation
If setting the property then it checks to see that it is set properly.
If it is not then an error is raised
If an error occurs during a query then an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenHasNullInput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 1;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns whether or not it is possible to set the preselector input port to none.</Description>
            </Property>
            <Property>
               <Name>iGenHighestFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 18e9;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1.8E10" Min="1.8E10"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>18000000000</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Query the highest possible frequency</Description>
            </Property>
            <Property>
               <Name>iGenInputPort</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% Read the state of the sixnet outputs corresponding to input ports
[PortBits, Success, ~] = ModbusDigitalRead(interfaceObj, 1, 1, 5);

if Success
  if sum(PortBits) == 0
    propertyValue = 0;
  else
    for ii = 1:5
      if PortBits(ii) == 1
        propertyValue = ii;
        break
      end
    end
  end
else %modbus error occurred
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

%if input is string convert to number
if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

% set up the input port bits. if zero is input all input port bits will be
% set to zero.
PortBits = [0 0 0 0 0];
if propertyValue ~= 0
  PortBits(propertyValue) = 1;
end

% set the modbus outputs
ModbusDigitalWrite(interfaceObj, 1, 1, PortBits);
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="Ant Port 1" Value="1"/>
                     <Enum Name="Ant Port 2" Value="2"/>
                     <Enum Name="Ant Port 3" Value="3"/>
                     <Enum Name="Ant Port 4" Value="4"/>
                     <Enum Name="Noise Diode" Value="5"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the desired input port or queries which input port is active.
A port number of 0 indicates that no port is selected.
If an error occurs during a query then the empty set [] is returned.</Description>
            </Property>
            <Property>
               <Name>iGenInputPortChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% Read the state of the sixnet outputs corresponding to input ports
[PortBits, Success, ErrMsg] = ModbusDigitalRead(interfaceObj, 1, 1, 5);

if Success
  if sum(PortBits) == 0
    propertyValue = 0;
  else
    for ii = 1:5
      if PortBits(ii) == 1
        propertyValue = ii;
        break
      end
    end
  end
else % Modbus error occurred
  propertyValue = [];
  error('Presel:Property:InputPort:ModbusQueryErr', ErrMsg);
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

%if input is string convert to number
if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

% set up the input port bits. if zero is input all input port bits will be
% set to zero.
PortBits = [0 0 0 0 0];
if propertyValue ~= 0
  PortBits(propertyValue) = 1;
end

% set the modbus outputs
[Success, ErrMsg] = ModbusDigitalWrite(interfaceObj, 1, 1, PortBits);

if Success
  % check the setting
  SetPort = get(obj, 'iGenInputPort');
  if SetPort ~= propertyValue
    error('Presel:Property:InputPort:SettingIncorrect',...
      'The preselector input port is not set as requested');
  end
else % there was a modbus problem
  error('Presel:Property:InputPort:ModbusWriteErr', ErrMsg);
end
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="Ant Port 1" Value="1"/>
                     <Enum Name="Ant Port 2" Value="2"/>
                     <Enum Name="Ant Port 3" Value="3"/>
                     <Enum Name="Ant Port 4" Value="4"/>
                     <Enum Name="Noise Diode" Value="5"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the antenna port.
If setting the property then it is checked to make sure it was set properly.
If it not set properly or a modbus error occurs then an error is raised.
If an error occurs during a query then the empty set is returned and an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenInstDescID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
out = get(interface, 'RemoteHost');
idx = findstr(out, '.');
propertyValue = ['RSMS4G 0.5-18GHz IP',out(idx(end):end)];</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the name of the instrument.
This is the same name as found in the miscellaneous function
getInstListAndDrivers.

For this driver should always return 'RSMS4G 0.5-18GHz IP.&lt;last octet&gt;'
</Description>
            </Property>
            <Property>
               <Name>iGenModelName</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 'RSMS4G 0.5-18GHz';</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>RSMS4G 0.5-18GHz</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the model name of the preseletcor. This is the same as 
InstDescID without the IP on the end. This model name is used in the
SetVCFPath fuction in the YIG Tracker driver so the name it returns must match 
what this function expects.</Description>
            </Property>
            <Property>
               <Name>iGenNumPaths</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 10;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Specifies the possible number of paths including no path
Returns the number of separate paths</Description>
            </Property>
            <Property>
               <Name>Path</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% read input bits from modbus modules 1 and 2 to be make single vector of
% length 9 later.
[IPathBits1, Success1, ~] = ModbusDigitalRead(interfaceObj, 1, 9, 8);
[IPathBits2, Success2, ~] = ModbusDigitalRead(interfaceObj, 2, 1, 1);

% read Output path bits
[OPathBits, Success3, ~] = ModbusDigitalRead(interfaceObj, 2, 2, 9);

if Success1 &amp;&amp; Success2 &amp;&amp; Success3
  IPathBits = [IPathBits1 IPathBits2];
  if sum(OPathBits) == 0 &amp;&amp; sum(IPathBits) == 0
    propertyValue = 0;
  elseif sum(OPathBits) == 1 &amp;&amp; sum(IPathBits) == 1
    % initialize propertyValue variable so it can be checked later.
    propertyValue = -999;
    for ii = 1:length(IPathBits)
      if (OPathBits(ii) + IPathBits(ii)) == 2
        propertyValue = ii;
      end
    end
    if propertyValue == -999 % bits do not correspond to legitimate path
      propertyValue = [];
    end
  else % read back bad data impossible path is selected
    propertyValue = [];
  end
else % modbus Error Ocurred
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

% initialize input and output path vector of bits
IPathBits = zeros(1,9);
OPathBits = zeros(1,9);

if propertyValue ~= 0
  IPathBits(propertyValue) = 1;
  OPathBits(propertyValue) = 1;
end

% write to the modbus devices.
ModbusDigitalWrite(interfaceObj, 1, 9, IPathBits(1:8));
ModbusDigitalWrite(interfaceObj, 2, 1, IPathBits(9));
ModbusDigitalWrite(interfaceObj, 2, 2, OPathBits);</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="Straight Through" Value="1"/>
                     <Enum Name="Band Pass 0.5-1 GHz" Value="2"/>
                     <Enum Name="Band Pass 1-2 GHz" Value="3"/>
                     <Enum Name="Band Pass 2-4 GHz" Value="4"/>
                     <Enum Name="Band Pass 4-8 GHz" Value="5"/>
                     <Enum Name="Band Pass 8-12 GHz" Value="6"/>
                     <Enum Name="Band Pass 12-18 GHz" Value="7"/>
                     <Enum Name="TNBL 0.5-2 GHz" Value="8"/>
                     <Enum Name="TNBL 2-18 GHz" Value="9"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the path number of the 0.5 - 18 GHz preselector.
This is primarily used internally by this driver and the instrument GUI for the 0.5-18 GHz Preselector.
It should not be used in a measurment. Use UniversalSetPath instead.</Description>
            </Property>
            <Property>
               <Name>PathRaiseError</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

% read input bits from modbus modules 1 and 2 to be make single vector of
% length 9 later.
[IPathBits1, Success1, ErrMsg1] = ModbusDigitalRead(interfaceObj, 1, 9, 8);
[IPathBits2, Success2, ErrMsg2] = ModbusDigitalRead(interfaceObj, 2, 1, 1);

% read Output path bits
[OPathBits, Success3, ErrMsg3] = ModbusDigitalRead(interfaceObj, 2, 2, 9);

if Success1 &amp;&amp; Success2 &amp;&amp; Success3
  IPathBits = [IPathBits1 IPathBits2];
  if sum(OPathBits) == 0 &amp;&amp; sum(IPathBits) == 0
    propertyValue = 0;
  elseif sum(OPathBits) == 1 &amp;&amp; sum(IPathBits) == 1
    % initialize propertyValue variable so it can be checked later.
    propertyValue = -999;
    for ii = 1:length(IPathBits)
      if (OPathBits(ii) + IPathBits(ii)) == 2
        propertyValue = ii;
      end
    end
    if propertyValue == -999 % bits do not correspond to legitimate path
      propertyValue = [];
    end
  else % read back bad data impossible path is selected
    propertyValue = [];
  end
else % modbus Error Ocurred
  propertyValue = [];
  if ~Success1
    error('Presel:Property:Path:ModbusQueryErr', ErrMsg1);
  elseif ~Success2
    error('Presel:Property:Path:ModbusQueryErr', ErrMsg2);
  else
    error('Presel:Property:Path:ModbusQueryErr', ErrMsg3);
  end
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interfaceObj = get(obj, 'interface');

if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

% initialize input and output path vector of bits
IPathBits = zeros(1,9);
OPathBits = zeros(1,9);

if propertyValue ~= 0
  IPathBits(propertyValue) = 1;
  OPathBits(propertyValue) = 1;
end

% write to the modbus devices.
[Success1, ErrMsg1] = ModbusDigitalWrite(interfaceObj, 1, 9, IPathBits(1:8));
[Success2, ErrMsg2] = ModbusDigitalWrite(interfaceObj, 2, 1, IPathBits(9));
[Success3, ErrMsg3] = ModbusDigitalWrite(interfaceObj, 2, 2, OPathBits);

if ~Success1
  error('Presel:Property:Path:ModbusWriteErr', ErrMsg1);
elseif ~Success2
  error('Presel:Property:Path:ModbusWriteErr', ErrMsg2);
elseif ~Success3
  error('Presel:Property:Path:ModbusWriteErr', ErrMsg3);
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="Straight Through" Value="1"/>
                     <Enum Name="Band Pass 0.5-1 GHz" Value="2"/>
                     <Enum Name="Band Pass 1-2 GHz" Value="3"/>
                     <Enum Name="Band Pass 2-4 GHz" Value="4"/>
                     <Enum Name="Band Pass 4-8 GHz" Value="5"/>
                     <Enum Name="Band Pass 8-12 GHz" Value="6"/>
                     <Enum Name="Band Pass 12-18 GHz" Value="7"/>
                     <Enum Name="TNBL 0.5-2 GHz" Value="8"/>
                     <Enum Name="TNBL 2-18 GHz" Value="9"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the path number of the 0.5 - 18 GHz preselector.
This is primarily used internally by this driver and the instrument GUI for the 0.5-18 GHz Preselector.
It should not be used in a measurment. Use UniversalSetPath instead.
Unlike Path this property will raise modbus errors if they occur.</Description>
            </Property>
            <Property>
               <Name>SerialNum</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
propertyValue = get(interface, 'RemoteHost')</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the serial number of the instrument.
For the case of preselectors this is the IP
</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>iGenAllPathProperties</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FilterType, FilterName, PathName, StartFreq, StopFreq, BandWidth, Amplifier, PathGain, NoiseFigure, CompressPt, ThrdOrdInt] = iGenAllPathProperties(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% No Path
FilterType{1} = 'NONE';
FilterName{1} = 'None';
PathName{1} = 'None';
StartFreq{1} = 0;
StopFreq{1} = 0;
BandWidth{1} = 0;
Amplifier{1} = 0;
PathGain{1} = 0;
NoiseFigure{1} = 0;
CompressPt{1} = 0;
ThrdOrdInt{1} = 5;
% through Path
FilterType{2} = 'BYP';
FilterName{2} = 'Bypass';
PathName{2} = 'Bypass';
StartFreq{2} = 0;
StopFreq{2} = 18000e6;
BandWidth{2} = 18000e6;
Amplifier{2} = 0;
PathGain{2} = 0;
NoiseFigure{2} = 0;
CompressPt{2} = 30;
ThrdOrdInt{2} = 5;
% .5-1 GHz BPF
FilterType{3} = 'BPF';
FilterName{3} = 'Band-Pass';
PathName{3} = 'BP 500-1000 MHz';
StartFreq{3} = 500e6;
StopFreq{3} = 1000e6;
BandWidth{3} = 500e6;
Amplifier{3} = 1;
PathGain{3} = 16;
NoiseFigure{3} = 0.7;
CompressPt{3} = 10;
ThrdOrdInt{3} = 5;
% 1-2 GHz BPF
FilterType{4} = 'BPF';
FilterName{4} = 'Band-Pass';
PathName{4} = 'BP 1-2 GHz';
StartFreq{4} = 960e6;
StopFreq{4} = 2000e6;
BandWidth{4} = 1040e6;
Amplifier{4} = 1;
PathGain{4} = 16;
NoiseFigure{4} = 0.8;
CompressPt{4} = 10;
ThrdOrdInt{4} = 5;
% 2-4 GHz BPF
FilterType{5} = 'BPF';
FilterName{5} = 'Band-Pass';
PathName{5} = 'BP 2-4 GHz';
StartFreq{5} = 2000e6;
StopFreq{5} = 4000e6;
BandWidth{5} = 2000e6;
Amplifier{5} = 1;
PathGain{5} = 24;
NoiseFigure{5} = 0.7;
CompressPt{5} = 8;
ThrdOrdInt{5} = 5;
% 4-8 GHz BPF
FilterType{6} = 'BPF';
FilterName{6} = 'Band-Pass';
PathName{6} = 'BP 4-8 GHz';
StartFreq{6} = 4000e6;
StopFreq{6} = 8000e6;
BandWidth{6} = 4000e6;
Amplifier{6} = 1;
PathGain{6} = 20;
NoiseFigure{6} = 0.9;
CompressPt{6} = 5;
ThrdOrdInt{6} = 5;
% 8-12 GHz BPF
FilterType{7} = 'BPF';
FilterName{7} = 'Band-Pass';
PathName{7} = 'BP 8-12 GHz';
StartFreq{7} = 8e9;
StopFreq{7} = 12000e6;
BandWidth{7} = 4000e6;
Amplifier{7} = 1;
PathGain{7} = 25;
NoiseFigure{7} = 1;
CompressPt{7} = 10;
ThrdOrdInt{7} = 5;
% 12-18 GHz BPF
FilterType{8} = 'BPF';
FilterName{8} = 'Band-Pass';
PathName{8} = 'BP 12-18 GHz';
StartFreq{8} = 12000e6;
StopFreq{8} = 18000e6;
BandWidth{8} = 6000e6;
Amplifier{8} = 1;
PathGain{8} = 28;
NoiseFigure{8} = 1.8;
CompressPt{8} = 10;
ThrdOrdInt{8} = 5;
% .5 - 2 YIG
FilterType{9} = 'VCF';
FilterName{9} = 'Voltage Controlled YIG';
PathName{9} = 'VCF 0.5-2 GHz';
StartFreq{9} = 500e6;
StopFreq{9} = 2000e6;
BandWidth{9} = 1500e6;
Amplifier{9} = 1;
PathGain{9} = 16;
NoiseFigure{9} = 1.5;
CompressPt{9} = 10;
ThrdOrdInt{9} = 5;
%2-18 YIG
FilterType{10} = 'VCF';
FilterName{10} = 'Voltage Controlled YIG';
PathName{10} = 'VCF 2-18 GHz';
StartFreq{10} = 2000e6;
StopFreq{10} = 18000e6;
BandWidth{10} = 16000e6;
Amplifier{10} = 1;
PathGain{10} = 28;
NoiseFigure{10} = 3;
CompressPt{10} = 13;
ThrdOrdInt{10} = 5;
</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>iGenGotNoiseDiode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NDPresent, PortNum, ENRValues] = iGenGotNoiseDiode(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NDPresent = 1;
PortNum = 5;

% get the IP address of the io module in the preselector
IPAdd = get(obj, 'SerialNum');

% create ENR Values based on which 0.5 - 18 GHz preselector is currently in
% use.
if strcmpi(IPAdd, '192.168.130.91')
  ENRValues(:,1) = [10 100 1000:1000:26000 26500];
  ENRValues(:,2) = [21.07 20.6 20.28 20.2 20.32 20.36 20.16 20.3 20.8 21.49,...
    21.65 21.93 22.17 21.99 22.19 22.55 22.09 21.52 22.15 22.45 22.01 22.01 22.75,...
    22.54 21.67 20.78 20.6 19.45 19.9];
else % next Gen Preselector
  ENRValues(:,1) = [10 100 1000:1000:18000];
  ENRValues(:,2) = [22.15 21.05 20.53 20.12 19.98 19.84 19.95 19.87 20.28, ...
    20.69 20.74 21.07 21.47 21.54 22.07 21.89 22.24 22.76 22.88 22.45];
end</MCode>
               </Code>
               <Description>queries the preselector to find out if it has a noise diode built in. If it does this function also returns the port number of the noise diode and a matrix containing the ENR values at stated frequencies. If no nosie diode is present this function returns the empty set for the port number and ENR.
The ENR value matrix is of the form:
ENRValues(:,1) = The frequencies
ENRValues(:,2) = the ENR values at the frequencies in ENRValues(:,1).
</Description>
            </Method>
            <Method>
               <Name>iGenInit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenInit(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% set RaiseError to false if not input
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interfaceObj = get(obj, 'interface');

% set all outputs to zero and raise error is on occurs and RaiseError =
% true.
[Success1, ErrMsg1] = ModbusDigitalWrite(interfaceObj, 1, 1, zeros(1,16));
if Success1
  [Success2, ErrMsg2] = ModbusDigitalWrite(interfaceObj, 2, 1, zeros(1,16));
  if ~Success2 &amp;&amp; RaiseError
    error('Presel:Function:Init:ModbusWriteErr', ErrMsg2);
  end
else
  if RaiseError
    error('Presel:Function:Init:ModbusWriteErr', ErrMsg1);
  end
end

</MCode>
               </Code>
               <Description>This subroutine resets all digital outputs on the IOTech modules, puting the Preselector in an initial
'inactive state with NO Input Ports, 0dB Attenuation, No Paths, and Noise Diode Power OFF.

If an error occurs the empty set is returned, and if RaiseError = true then an error is raised.</Description>
            </Method>
            <Method>
               <Name>iGenMaxAttenuation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MaxAtten, AttenInc] = iGenMaxAttenuation(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
MaxAtten = 70;
AttenInc = 10;</MCode>
               </Code>
               <Description>This command returns the maximum available attenuation and how the attenuation can be incremented</Description>
            </Method>
            <Method>
               <Name>iGenNoiseDiodeState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function NDState = iGenNoiseDiodeState(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% set RaiseError to false if not input
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interfaceObj = get(obj, 'interface');

% read the state of the io module output controlling the noise diode power.
[NDState, Success, ErrMsg] = ModbusDigitalRead(interfaceObj, 2, 11, 1);

% raise error if one occurrs and requested
if ~Success &amp;&amp; RaiseError
  error('Presel:Function:NoiseDiodeState:ModbusReadErr', ErrMsg);
end</MCode>
               </Code>
               <Description>Returns the current state of the power to the noise diode, where 0 = noise diode off and
1 = noise diode on.

If an error occurs the empty set is returned and if RaiseError = true then an error is raised.</Description>
            </Method>
            <Method>
               <Name>iGenNumInputPorts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumPorts, PortNames] = iGenNumInputPorts(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NumPorts = 6;
PortNames = {'None', 'Ant Port 1', 'Ant Port 2', 'Ant Port 3', 'Ant Port 4',...
  'Noise Diode'};</MCode>
               </Code>
               <Description>This function returns the number of input ports and their names. The names must be in the same order as they are set in InputPort and be set as valid inputs to the InputPort property. There must be a place holder for no input port. In no zero port is available set name to N/A</Description>
            </Method>
            <Method>
               <Name>iGenProbeTemp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function degC = iGenProbeTemp(obj, WhichProbe, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% set RaiseError to false if not input
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interfaceObj = get(obj, 'interface');

% read the analog input
[TempOut, Success, ErrMsg] = ModbusAnalogRead(interfaceObj, 3, WhichProbe, 1);

if Success
  degC = TempOut*0.1;
else
  if RaiseError
    error('Presel:Function:ProbeTemp:ModbusReadErr', ErrMsg);
  end
end
</MCode>
               </Code>
               <Description>' This function returns the temperature value of the selected probe, WhichProbe.
' For the Presel4Gp5_18 Preselector, there are 3 temperature probes (numbered 0 to 2) as follows:
' Probe 1:  Enclosure
' Probe 2:  YIG 0.5-2.0GHz
' Probe 3:  Low Noise Amplifier

If an error occurs the empty set is returned, and if RaiseError = true then an error is raised.</Description>
            </Method>
            <Method>
               <Name>iGenSetNoiseDiode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetNoiseDiode(obj, On, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% create RaiseError and ChkResult if they are not input. The default for
% these inputs is false.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% get the interface object
interfaceObj = get(obj, 'interface');

% set the i/o module output
if On
  [Success, ErrMsg] = ModbusDigitalWrite(interfaceObj, 2, 11, 1);
else
  [Success, ErrMsg] = ModbusDigitalWrite(interfaceObj, 2, 11, 0);
end

if Success
  if ChkResult % check to make sure noise diode was set as requested
    NDOn = invoke(obj, 'iGenNoiseDiodeState');
    if NDOn ~= On
      if RaiseError
        error('Presel:Function:SetNoiseDiode:SettingIncorrect',...
          'The noise diode is not set as requested.');
      end
    end
  end
else % there was a Modbus Error
  if RaiseError
    error('Presel:Function:SetNoiseDiode:ModbusWriteErr', ErrMsg);
  end
end</MCode>
               </Code>
               <Description>Designates, by argument On, whether to turn the power to the noise diode on or off,
where 0 = off and 1 = on.  

If RaiseError = true then errors will be raised should they occur.
If ChkResult = true then the setting is checked and an error is raised if RaiseError = true.
If ChkResult = true then RaiseError should also be true otherwise there is no way to report
the error.</Description>
            </Method>
            <Method>
               <Name>iGenTempProbes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumProbes, ProbeIDs] = iGenTempProbes(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NumProbes = 3;
ProbeIDs = {'Enclosure', '0.5-2 GHz YIG', 'LNA'};</MCode>
               </Code>
               <Description>Specifies the possible temperature probes, returns the number of available probes and their IDS
</Description>
            </Method>
            <Method>
               <Name>iGenUniversalGetPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StartFreq, StopFreq, FilterType, FilterName] = iGenUniversalGetPath(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% Read the Path number from the preselector
if RaiseError
  try
    PathNum = get(obj, 'PathRaiseError');
  catch oops
    error('Preselector:Function:UniversalGetPath:ModbusErr',oops.message);
  end
else
  PathNum = get(obj, 'Path');
end

% get the property Values for the returned Path.
[FilterType, ~, FilterName, StartFreq, StopFreq, ~, ~, ~, ~, ~, ~] = invoke(obj, 'PathPropertiesByPath', PathNum);</MCode>
               </Code>
               <Description>This function returns the set path in the form of minimum and maximum freqeuncies and the filter type for the returned path number.

If RaiseError = true errors will be raised for modbus errors if it is false and errors occur empty sets will be returned for all the output arguments.</Description>
            </Method>
            <Method>
               <Name>iGenUniversalPathProperties</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FiltType, FilterName, PathName, f1, f2, BW, Amp, G, NF, CompPt, ThrdOrd] = iGenUniversalPathProperties(obj, CenterFreq, FilterType, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
ItWorked = true;
switch FilterType
  case 'NONE'
    PathNum = 0;
  case 'BYP'
    PathNum = 1;
  case 'BPF'
    if CenterFreq &gt;= 500e6 &amp;&amp; CenterFreq &lt;= 1e9
      PathNum = 2;
    elseif CenterFreq &gt;= 1e9 &amp;&amp; CenterFreq &lt;= 2e9
      PathNum = 3;
    elseif CenterFreq &gt;= 2e9 &amp;&amp; CenterFreq &lt;= 4e9
      PathNum = 4;
    elseif CenterFreq &gt;= 4e9 &amp;&amp; CenterFreq &lt;= 8e9
      PathNum = 5;
    elseif CenterFreq &gt;= 8e9 &amp;&amp; CenterFreq &lt;= 12e9
      PathNum = 6;
    elseif CenterFreq &gt;= 12e9 &amp;&amp; CenterFreq &lt;= 18e9
      PathNum = 7;
    else
      % Freq not in range
      ItWorked = false;
    end
  case 'VCF'
    if CenterFreq &gt;= 0.5e9 &amp;&amp; CenterFreq &lt;= 2e9
      PathNum = 8;
    elseif CenterFreq &gt;= 2e9 &amp;&amp; CenterFreq &lt;= 18e9
      PathNum = 9;
    else
      ItWorked = false;
    end
  otherwise
    % invalid filter type
    ItWorked = false;
end
if ItWorked
  [FiltType, FilterName, PathName, f1, f2, BW, Amp, G, NF, CompPt, ThrdOrd] = invoke(obj, 'PathPropertiesByPath', PathNum);
else
  FiltType = {};
  filterName = {};
  PathName = {};
  f1 = [];
  f2 = [];
  BW = [];
  Amp = [];
  G = [];
  NF = [];
  CompPt = [];
  ThrdOrd = [];
  if RaiseError
    error('Presel:Function:UniversalPathProperties:InvalidInput',...
      'The input arguments do not correspond to a valid path. This function has not returned any values.');
  end
end</MCode>
               </Code>
               <Description>queries properties of the chosen path given the center freq and filter type.

If an invalid path is input enpty sets for all property values are returned if RaiseError = false.
If RaiseError = true than an error is raised when an invalid path is chosen.</Description>
            </Method>
            <Method>
               <Name>iGenUniversalSetPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenUniversalSetPath(obj, FStart, FStop, FilterType, RaiseError, ChkResult)

% create RaiseError and/or ChkResult variables if they are not input. False
% is the default for these variables.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% get interface
interface = get(obj, 'interface');
ItWorked = true;
switch FilterType
  case 'NONE'
    PathNum = 0;
  case 'BYP'
    PathNum = 1;
  case 'BPF'
    if FStart &gt;= 500e6 &amp;&amp; FStop &lt;= 1e9
      PathNum = 2;
    elseif FStart &gt;= 960e6 &amp;&amp; FStop &lt;= 2e9
      PathNum = 3;
    elseif FStart &gt;= 2e9 &amp;&amp; FStop &lt;= 4e9
      PathNum = 4;
    elseif FStart &gt;= 4e9 &amp;&amp; FStop &lt;= 8e9
      PathNum = 5;
    elseif FStart &gt;= 8e9 &amp;&amp; FStop &lt;= 12e9
      PathNum = 6;
    elseif FStart &gt;= 12e9 &amp;&amp; FStop &lt;= 18e9
      PathNum = 7;
    else
      % Warning Frequency is out of range
      ItWorked = false;
    end
  case 'VCF'
    if FStart &gt;= 500e6 &amp;&amp; FStop &lt;= 2e9
      PathNum = 8;
    elseif FStart &gt;= 2e9 &amp;&amp; FStop &lt;= 18e9
      PathNum = 9;
    else
      % warning freq out of range
      ItWorked = false;
    end
  otherwise
    % warning invalid filter type selected
    ItWorked = false;
end

% deal with any error reporting that is asked for.
if ItWorked
  if RaiseError %set path using property that raises errors.
    try
      set(obj, 'PathRaiseError', PathNum);
    catch oops
      error('Presel:Property:Path:ModbusErr', oops.message);
    end
  else
    set(obj, 'Path', PathNum);
  end
  % Check the set path to make sure it is what was asked for if RaiseError = true.
  if ChkResult &amp;&amp; RaiseError
    try
      SetPath = get(obj, 'PathRaiseError');
    catch oops2
      error('Presel:Property:Path:ModbusErr', oops2.message);
    end
    if SetPath ~= PathNum
      error('Presel:Function:UniversalSetPath:SettingIncorrect',...
        ['The path is not set as requested. Set to path ',num2str(SetPath)]);
    end
  end
else
  if RaiseError
    error('Presel:Function:UniversalSetPath:InvalidInput',...
      'The path has not been changed. The input parameters do not clearly define a valid path');
  end
end
</MCode>
               </Code>
               <Description>Sets the path using start frequency, stop frequency, and filter type.
This function is present so that measurements can use it to set the path regardless of whether the preselector is set by freq or path.
The filter Types are as follows:
"NONE" = No Filter, Open Path
"BYP" = Straight Through coupled
"AUX" = Auxillary Path
"BPF" = Band pass Filter
"BRF" = Band Reject Filter
"LPF" = Low Pass Filter
"HPF" = High Pass Filter
"TNBL" = Tunable Filter frequency set by preselector
"GAIN" = Gain Path
"VCF" = votage controlled filter path control voltage external to preselector.

If RaiseError = true, errors will be raised for modbus errors or if the setting is not set as requested (as long as ChkResult is also true).
If ChkResult = true and RaiseError = false the setting will not be checked so if ChkResult = true RaiseError should also be true.
</Description>
            </Method>
            <Method>
               <Name>PathPropertiesByPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FilterType, FilterName, PathName, StartFreq, StopFreq, BandWidth, Amplifier, PathGain, NoiseFigure, CompressPt, ThrdOrdInt] = PathPropertiesByPath(obj, PathNum)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
switch PathNum
  case 0
    FilterType = 'NONE';
    FilterName = 'None';
    PathName = 'None';
    StartFreq = 0;
    StopFreq = 0;
    BandWidth = 0;
    Amplifier = 0;
    PathGain = 0;
    NoiseFigure = 0;
    CompressPt = 0;
    ThrdOrdInt = 5;
  case 1
    FilterType = 'BYP';
    FilterName = 'Bypass';
    PathName = 'Bypass';
    StartFreq = 0;
    StopFreq = 18000e6;
    BandWidth = 18000e6;
    Amplifier = 0;
    PathGain = 0;
    NoiseFigure = 0;
    CompressPt = 30;
    ThrdOrdInt = 5;
  case 2
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 500-1000 MHz';
    StartFreq = 500e6;
    StopFreq = 1000e6;
    BandWidth = 500e6;
    Amplifier = 1;
    PathGain = 16;
    NoiseFigure = 0.7;
    CompressPt = 10;
    ThrdOrdInt = 5;
  case 3
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 1-2 GHz';
    StartFreq = 960e6;
    StopFreq = 2000e6;
    BandWidth = 1040e6;
    Amplifier = 1;
    PathGain = 16;
    NoiseFigure = 0.8;
    CompressPt = 10;
    ThrdOrdInt = 5;
  case 4
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 2-4 GHz';
    StartFreq = 2000e6;
    StopFreq = 4000e6;
    BandWidth = 2000e6;
    Amplifier = 1;
    PathGain = 24;
    NoiseFigure = 0.7;
    CompressPt = 8;
    ThrdOrdInt = 5;
  case 5
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 4-8 GHz';
    StartFreq = 4000e6;
    StopFreq = 8000e6;
    BandWidth = 4000e6;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 0.9;
    CompressPt = 5;
    ThrdOrdInt = 5;
  case 6
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 8-12 GHz';
    StartFreq = 8e9;
    StopFreq = 12000e6;
    BandWidth = 4000e6;
    Amplifier = 1;
    PathGain = 25;
    NoiseFigure = 1;
    CompressPt = 10;
    ThrdOrdInt = 5;
  case 7
    FilterType = 'BPF';
    FilterName = 'Band-Pass';
    PathName = 'BP 12-18 GHz';
    StartFreq = 12000e6;
    StopFreq = 18000e6;
    BandWidth = 6000e6;
    Amplifier = 1;
    PathGain = 28;
    NoiseFigure = 1.8;
    CompressPt = 10;
    ThrdOrdInt = 5;
  case 8
    FilterType = 'VCF';
    FilterName = 'Voltage Controlled YIG';
    PathName = 'VCF 0.5-2 GHz';
    StartFreq = 500e6;
    StopFreq = 2000e6;
    BandWidth = 1500e6;
    Amplifier = 1;
    PathGain = 16;
    NoiseFigure = 1.5;
    CompressPt = 10;
    ThrdOrdInt = 5;
  case 9
    FilterType = 'VCF';
    FilterName = 'Voltage Controlled YIG';
    PathName = 'VCF 2-18 GHz';
    StartFreq = 2000e6;
    StopFreq = 18000e6;
    BandWidth = 16000e6;
    Amplifier = 1;
    PathGain = 28;
    NoiseFigure = 3;
    CompressPt = 13;
    ThrdOrdInt = 5;
  otherwise
    FilterType = {};
    FilterName = {};
    PathName = {};
    StartFreq = [];
    StopFreq = [];
    BandWidth = [];
    Amplifier = [];
    PathGain = [];
    NoiseFigure = [];
    CompressPt = [];
    ThrdOrdInt = [];
    %Throw Warning invalid path number sent
end
</MCode>
               </Code>
               <Description>' Returns path properties for the specified path indicated by the argument "PathNum".
'    The arguments returned are as follows:
'   1)  PathFilterType As String: this is the filter characteristic type.  The following Filter types are supported:
'         "None" = No Filter, Open Path
'         "BYP" = Straight Through coupled
'         "AUX" = Auxillary Path
'         "BPF" = Band pass Filter
'         "BRF" = Band Reject Filter
'         "LPF" = Low Pass Filter
'         "HPF" = High Pass Filter
'         "TNBL" = Tunable Filter
'          "Gain" = Gain Path
'   2)  StartFreq As Double:  this is the 3dB cutoff frequency (in Hz) for the lower end of a fixed filter's frequency band.
'                             For tunable filters, this is the Minimum tunable frequency.
'   3)  StopFreq As Double:  this is the 3dB cutoff frequency (in Hz) for the upper end of a fixed filter's frequency band.
'                             For tunable filters, this is the Maximum tunable frequency.
'   4)  Bandwidth As Double:  this is the 3 dB bandwidth (in Hz) of the narrowest filter in the path, be it a fixed
'         filter or a tunable filter. For a fixed filter the bandwidth is equal to (StopFreq - StartFreq)
'   5)  Amplifier As Integer:  indicates if an amplifier is included in the path. 0 = No Amplifier, 1 = Amplifier present
'   6)  PathGain:  this is the average gain (in dB) for the path EXCLUDING the attenuator.
'   7)  NoiseFigure:  this is the avereage Noise Figure in dBm for the path
'   8)  ByRef CompressPt As Single: this is the average 1-dB compression point (in dBm) for the path.
'   9)  ByRef ThrdOrdInt As Single: this is the average third-order intercept point (in dBm)
'         for the path.
' The argument "PathNum" designates the path for which the properties are requested, where the value
'   can be any value from 0 to (Number of paths).</Description>
            </Method>
            <Method>
               <Name>SetByFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function out = SetByFreq(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
out = false;</MCode>
               </Code>
               <Description>'Indicates whether the paths within the preselector are automatically set simply by sending a center
'  frequency (example HP85685 preselector).  The 3G and 4G preselectors paths are set by designating
'  a path, as appoosed to a center frequency
'false = path set by disignating the path
'true = path is set automatically by sending a center frequency</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>