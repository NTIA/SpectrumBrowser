<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>C:\Matlab Instr Control\Stepped\RSMS5GTest\Drivers\tektronixTDS5104.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Tektronix</InstrumentManufacturer>
   <InstrumentModel>TDS5104</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify>*IDN?</Identify>
   <Reset>*RST;HEADER OFF;VERBOSE ON</Reset>
   <Selftest>*TST?</Selftest>
   <Error>*ESR?;ALLEv?</Error>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface = get(obj, 'Interface');
fclose(interface);
set(interface, 'InputBufferSize', 101000);
set(interface, 'OutputBufferSize', 101000);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface = get(obj, 'Interface');
fprintf(interface, 'HEADER OFF');
fprintf(interface, 'VERBOSE ON');
query(interface, '*ESR?');</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>InstrumentCommand</Type>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>ByteOrder</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>WFMOutpre:BYT_Or</ConfigureCommand>
                     <QueryCommand>WFMOutpre:BYT_Or?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="bigEndian" Value="MSB"/>
                     <Enum Name="littleEndian" Value="LSB"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>bigEndian</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Coupling</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>Never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Precision</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

% Get interface
interface = get(obj,'interface');
propertyValue = '';

% Set data width 
fprintf(interface,'WFMO:Byt_NR?')
width = fscanf(interface);

% Remove the newline character at the end of the string
% The same is done for encoding
width(length(width))= '';
width  = str2num(width);

% Check the data format and define propertyValue to the appropriate value
fprintf(interface,'DATA:ENCdg?')
encoding  = fscanf(interface);
encoding(length(encoding)) = '';

% define propertyValue with the right value
if any(strcmpi(encoding,{'RIBinary','SRIbinary'}))
    propertyValue = ['int' num2str(8*width)];
elseif any(strcmpi(encoding,{'RPBinary','SRPbinary'}))
     propertyValue = ['uint' num2str(8*width)];
else propertyValue = 'ascii';
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

% Get interface
interface = get(obj,'interface');

% Get the byte order
fprintf(interface,'WFMOutPre:BYT_Or?')

% Get the order and remove newline character in string
order = fscanf(interface);
order(length(order)) = '';

% Only an S differenciates the two commands(RIBinary and SRIBinary)
% for signed integers. The S will be added to the command if the byte 
% order is LSB
byteOrder ='';
if strcmpi(order,'LSB') == 1
    byteOrder = 'S';
end

% Specify format
if strcmpi(propertyValue,'ascii')
    fprintf(interface,['DATA:ENCdg ASCIi'])
    %setting data:enc to ASCII reset Byte_Or to MSB, which is unneccssary.
    %this sets it back to what is was previously.
    fprintf(interface,['WFMOutPre:BYT_Or ',order]);
elseif any(strcmpi(propertyValue,{'int8','int16'}))
    fprintf(interface,['DATA:ENCdg ' byteOrder 'RIBinary'])
elseif any(strcmpi(propertyValue,{'uint8','uint16','uint32','unit64'}))
  fprintf(interface,['DATA:ENCdg ' byteOrder 'RPBinary'])
end

% Set the width
if any(strcmpi(propertyValue,{'int8','uint8'}))
    fprintf(interface,['WFMO:Byt_NR 1'])
elseif any(strcmpi(propertyValue,{'int16','uint16'}))
    fprintf(interface,['WFMO:Byt_NR 2'])
elseif any(strcmpi(propertyValue,{'int32','uint32'}))
    fprintf(interface,['WFMO:Byt_NR 4'])
elseif any(strcmpi(propertyValue,{'int64','uint64'}))
    fprintf(interface,['WFMO:Byt_NR 8'])
else
    fprintf(interface,['WFMO:Byt_NR 1']);
   % error('Invalid format. Valid values are: int8,int16, uint8,uint16.')
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ascii" Value="ASCIi"/>
                     <Enum Name="int8" Value="int8"/>
                     <Enum Name="int16" Value="int16"/>
                     <Enum Name="uint8" Value="uint8"/>
                     <Enum Name="uint16" Value="uint16"/>
                     <Enum Name="int32" Value="int32"/>
                     <Enum Name="int64" Value="int64"/>
                     <Enum Name="uint32" Value="uint32"/>
                     <Enum Name="uint64" Value="uint64"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ascii</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>getTrace</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [x, y, xunit, yunit] = getTrace(obj, source, Scale)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

num1 = 1;
num2 = 4;
snum1 = num2str(num1);
snum2 = num2str(num2);

if (nargout == 0)
    return;
end

scale = true;
y = [];
x = [];
yunit = 'unknown';
xunit = 'unknown';

if strcmpi(source(1),'c')
	type = 'ch';	
elseif strcmpi(source(1),'r')
	type = 'ref';	
elseif strcmpi(source(1),'m')
	type = 'math';	
else
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

try
	pos = str2num(source(length(source)));
catch
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

if pos&lt;num1 || pos&gt;num2
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

trueSource = [type, num2str(pos)];

if (nargin &gt; 2)
    try
        scale = logical(Scale);
    catch
        error('SCALE must be a logical.');
    end
end

% Get interface
interface = get(obj, 'interface');

oldPrecision = get(obj, 'Precision');
oldByteOrder = get(obj, 'ByteOrder');

set(obj, 'Precision', 'int16');
set(obj, 'ByteOrder', 'littleEndian');

try 
    % Specify source
    fprintf(interface,['DATA:SOURCE ' trueSource]);

    % Issue the curve transfer command.
    fprintf(interface, 'CURVE?');

    raw = binblockread(interface, 'int16');

    % Tektronix scopes send and extra terminator after the binblock.
    fread(interface, 1);
catch
	%if there is a problem with binblockread, you will not be able to reset
	% Precision or ByteOrder
    error(lasterr);
end

if (isempty(raw))
    set(obj, 'Precision', oldPrecision);
    set(obj, 'ByteOrder', oldByteOrder);
    error('An error occurred while reading the waveform.');
end

if (scale == false)
    y = raw;
    if (nargout &lt; 2)
        set(obj, 'Precision', oldPrecision);
        set(obj, 'ByteOrder', oldByteOrder);
        return;
    end
    ptcnt = str2num(query(interface, 'WFMoutPRE:NR_PT?'));
    x = 1:ptcnt;
    
    if (nargout &gt; 2)
        xunit = query(interface, 'WFMoutPRE:XUnit?');
        xunit(xunit == '"') = [];
        yunit = query(interface, 'WFMoutPRE:YUnit?');
        yunit(yunit == '"') = [];
    end
else
    yoffs = str2num(query(interface, 'WFMoutPRE:YOFF?'));
    ymult = str2num(query(interface, 'WFMoutPRE:YMULT?'));
    yzero = str2num(query(interface, 'WFMoutPRE:YZERO?'));
    y = ((raw - yoffs) .* ymult) + yzero;
    if (nargout &lt; 2)
        set(obj, 'Precision', oldPrecision);
        set(obj, 'ByteOrder', oldByteOrder);
        return;
    end
    xzero = str2num(query(interface, 'WFMoutPRE:XZERO?'));
    xincr = str2num(query(interface, 'WFMoutPRE:XINCR?'));
    ptcnt = str2num(query(interface, 'WFMoutPRE:NR_PT?'));
    x = (((0:(ptcnt-1)) .* xincr) + xzero);
    
    if (nargout &gt; 2)
        xunit = query(interface, 'WFMoutPRE:XUnit?');
        xunit(xunit == '"') = [];
        yunit = query(interface, 'WFMoutPRE:YUnit?');
        yunit(yunit == '"') = [];
    end
end
y = y';

set(obj, 'Precision', oldPrecision);
set(obj, 'ByteOrder', oldByteOrder);</MCode>
               </Code>
               <Description>getTrace Transfer waveforms from the oscilloscope to MATLAB.

Input in General instrument UI for CHANNEL must be in single quotes

[Y, T] = INVOKE(obj, 'getTrace', CHANNEL) returns a waveform from the instrument,
using channel string, CHANNEL.  Valid channel values are channel&lt;x&gt;, reference&lt;y&gt;, and
math, where &lt;x&gt; is a number between 1 and the number of channels on the instrument and &lt;y&gt; is a letter between A and the number of reference channels on the instrument.

[Y, T] = INVOKE(obj, 'getTrace', CHANNEL, SCALE) returns the data scaled to real units if SCALE is true, or as raw data if SCALE is false.

To read the waveform data points the interface object associated with the device
object must have a sufficiently large InputBufferSize property value.  If you receive
an error about the buffer size being to small, or have difficulty reading a waveform,
verify that it is large enough.  The size must be greater than two times the number
of points in the waveform, plus approximately 50 bytes for header information.

Example:
	[y, t] = invoke(obj, 'readwaveform', 'channel1');
	[y, t] = invoke(obj, 'readwaveform', 'referenceA', false);

Example changing the buffer size:
	% Note the device object must be closed.
	interfaceObj = get(deviceObj, 'interface');
	% Allow for a 10,000 point waveform with a little extra room.
	set(interfaceObj, 'InputBufferSize', 21000);
	connect(deviceObj);
	[y, t] = invoke(obj, 'readwaveform', 'channel1');

</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>