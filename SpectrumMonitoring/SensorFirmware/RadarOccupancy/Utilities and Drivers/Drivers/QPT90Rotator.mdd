<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>C:\RSMS5G\Drivers\QPT90Rotator.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Rotator</InstrumentType>
   <InstrumentManufacturer>QuickSet</InstrumentManufacturer>
   <InstrumentModel>QPT90</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
set(interface, 'OutputBufferSize', 256);
set(interface, 'InputBufferSize', 256);
set(interface, 'Terminator', 'CR');
% put the rotator into remote mode
fopen(interface)
fprintf(interface, 'FF1');
fclose(interface);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
% put the rotator into remote mode
interface=get(obj,'interface');
fprintf(interface, '&amp;FF1');</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
IFaceStatus = get(interface, 'status');
if strcmp(IFaceStatus, 'open')
  % take the rotator out of remote mode
  fprintf(interface, '&amp;FF0');
  fclose(interface);
end</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>iGenAzimuthPos</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  RawAzVal = hex2dec(out(9:11));
else
  ItWorked = false;
end
if ItWorked
  [AzOffset, AzScalar] = invoke(obj, 'GetOffSetAndScalar', 0);
  if ~isempty(AzOffset) &amp;&amp; ~isempty(AzScalar)
    propertyValue = (RawAzVal - AzOffset)/AzScalar
  else
    propertyValue = [];
  end
else
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
% get the current elevation angle.
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  CurrElevValHex = out(13:15);
else
  ItWorked = false;
end
% convert the input degree value to hex value needed by set command
if ItWorked
  [AzOffset, AzScalar] = invoke(obj, 'GetOffSetAndScalar', 0);
  RawAZVal = round((propertyValue*AzScalar) + AzOffset);
  AzValHex = dec2hex(RawAZVal);
  % set the position
  CC = ComputeCheckSum(['$00B0210',AzValHex,'0',CurrElevValHex]);
  fprintf(IFace, ['$00B0210',AzValHex,'0',CurrElevValHex,CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    if strcmp(out(end),'n')
      % Comm Error Nack
    else % wait until it finishes moving
      Stopped = false;
      while ~Stopped
        fprintf(IFace, '$00B03059');
        BufferReady = WaitforBuffer(IFace, 5);
        if BufferReady
          out = fscanf(IFace, '%c');
          Moving = out(8);
          if strcmpi(Moving, 'S')
            Stopped = true;
          end
        else % break out of loop there is a propblem
          Stopped = true;
        end
      end
    end
  end
end
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="180.0" Min="-180.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This functions sets or gets the azimuth position. When setting the position the rotator will move to the set position.
</Description>
            </Property>
            <Property>
               <Name>iGenAzimuthPosChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenAzimuthPos')</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
% get the current elevation angle.
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  CurrElevValHex = out(13:15);
else
  ItWorked = false;
end
% convert the input degree value to hex value needed by set command
if ItWorked
  [AzOffset, AzScalar] = invoke(obj, 'GetOffSetAndScalar', 0);
  RawAZVal = round((propertyValue*AzScalar) + AzOffset);
  AzValHex = dec2hex(RawAZVal);
  % set the position
  CC = ComputeCheckSum(['$00B0210',AzValHex,'0',CurrElevValHex]);
  fprintf(IFace, ['$00B0210',AzValHex,'0',CurrElevValHex,CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    if strcmp(out(end),'n')
      % Comm Error Nack
    else % wait until it finishes moving
      Stopped = false;
      while ~Stopped
        fprintf(IFace, '$00B03059');
        BufferReady = WaitforBuffer(IFace, 5);
        if BufferReady
          out = fscanf(IFace, '%c');
          Moving = out(8);
          if strcmpi(Moving, 'S')
            Stopped = true;
          end
        else % break out of loop there is a propblem
          Stopped = true;
        end
      end
    end
  end
  % Check to make sure the setting was made properly
  SetAz = get(obj, 'iGenAzimuthPos');
  if ~WithinTol(SetAz, propertyValue, .4, true)
    error('Rotator:Property:AzimuthPos:SettingIncorrect',...
        ['The rotator position has not been set as requested. Currently at: ',...
        num2str(SetAz),' Deg azimuth.']);
  end
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="180.0" Min="-180.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This functions sets or gets the azimuth position. When setting the position the rotator will move to the set position.
After the position is set this function checks to make sure it was set properly. If is has not been set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenElevationPos</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  RawElVal = hex2dec(out(13:15));
else
  ItWorked = false;
end
if ItWorked
  [ElOffset, ElScalar] = invoke(obj, 'GetOffSetAndScalar', 1);
  if ~isempty(ElOffset) &amp;&amp; ~isempty(ElScalar)
    propertyValue = (RawElVal - ElOffset)/ElScalar
  else
    propertyValue = [];
  end
else
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
% get the current elevation angle.
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  CurrAzimValHex = out(9:11);
else
  ItWorked = false;
end
% convert the input degree value to hex value needed by set command
if ItWorked
  [ElevOffset, ElevScalar] = invoke(obj, 'GetOffSetAndScalar', 1);
  RawElVal = round((propertyValue*ElevScalar) + ElevOffset);
  ElValHex = dec2hex(RawElVal);
  % set the position
  CC = ComputeCheckSum(['$00B0210',CurrAzimValHex,'0',ElValHex]);
  fprintf(IFace, ['$00B0210',CurrAzimValHex,'0',ElValHex,CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    if strcmp(out(end),'n')
      % Comm Error Nack
    else % wait until it finishes moving
      Stopped = false;
      while ~Stopped
        fprintf(IFace, '$00B03059');
        BufferReady = WaitforBuffer(IFace, 5);
        if BufferReady
          out = fscanf(IFace, '%c');
          Moving = out(12);
          if strcmpi(Moving, 'S')
            Stopped = true;
          end
        else % break out of loop there is a propblem
          Stopped = true;
        end
      end
    end
  end
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="90.0" Min="-90.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This functions sets or gets the elevation position. When setting the position the rotator will move to the set position. Normal seek speed will be used. 
</Description>
            </Property>
            <Property>
               <Name>iGenElevationPosChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenElevationPos');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
ItWorked = true;
% get the current elevation angle.
fprintf(IFace, '$00B03059');
BufferReady = WaitforBuffer(IFace, 5);
if BufferReady
  out = fscanf(IFace, '%c');
  CurrAzimValHex = out(9:11);
else
  ItWorked = false;
end
% convert the input degree value to hex value needed by set command
if ItWorked
  [ElevOffset, ElevScalar] = invoke(obj, 'GetOffSetAndScalar', 1);
  RawElVal = round((propertyValue*ElevScalar) + ElevOffset);
  ElValHex = dec2hex(RawElVal);
  % set the position
  CC = ComputeCheckSum(['$00B0210',CurrAzimValHex,'0',ElValHex]);
  fprintf(IFace, ['$00B0210',CurrAzimValHex,'0',ElValHex,CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    if strcmp(out(end),'n')
      % Comm Error Nack
    else % wait until it finishes moving
      Stopped = false;
      while ~Stopped
        fprintf(IFace, '$00B03059');
        BufferReady = WaitforBuffer(IFace, 5);
        if BufferReady
          out = fscanf(IFace, '%c');
          Moving = out(12);
          if strcmpi(Moving, 'S')
            Stopped = true;
          end
        else % break out of loop there is a propblem
          Stopped = true;
        end
      end
    end
  end
  % Check the setting
  SetEl = get(obj, 'iGenElevationPos');
  if ~WithinTol(SetEl, propertyValue, .4, true)
    error('Rotator:Property:ElevationPos:SettingIncorrect',...
        ['The rotator position has not been set as requested. Currently at: ',...
        num2str(SetEl),' Deg elevation.']);
  end
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="90.0" Min="-90.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This functions sets or gets the elevation position. When setting the position the rotator will move to the set position. Normal seek speed will be used. 
After the position is set this function checks to make sure it was set properly. If is has not been set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenInstDescID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 'QPT90 Rotator';</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>GetOffSetAndScalar</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Offset, Scalar] = GetOffSetAndScalar(obj, AzOrEl)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
ItWorked = true;
IFace = get(obj, 'interface');
if ~AzOrEl %Azimuth
  idxoffset = [-1 9];
else
  idxoffset = [1 12];
end
% read in the offset value from memory. 2 Bytes that need to be converted
% to single 16 bit value.
for ii = 1:2
  CC = ComputeCheckSum(['$00B002000',num2str(ii+idxoffset(1))]);
  fprintf(IFace, ['$00B002000',num2str(ii+idxoffset(1)),CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    temp{ii} = out(8:9);
  else
    ItWorked = false;
  end
end
if ItWorked  
  Offset = hex2dec([temp{2} temp{1}]);
else
  Offset = [];
end
% read in the scalar value from memory. 2 Bytes that need to be converted
% to single 16 bit value.
for ii = 1:2
  CC = ComputeCheckSum(['$00B002000',dec2hex(ii+idxoffset(2))]);
  fprintf(IFace, ['$00B002000',dec2hex(ii+idxoffset(2)),CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    temp{ii} = out(8:9);
  else
    ItWorked = false;
  end
end
if ItWorked
  RawScalar = hex2dec([temp{2} temp{1}]);
  Scalar = floor((RawScalar/16))+(mod(RawScalar,16)/16);
else
  Scalar = [];
end
</MCode>
               </Code>
               <Description>This function returns the offset and scalar for either the azimuth or elevation specified by AzorEl.
AzorEl = 0 means Azimuth
AzorEl = 1 means elevation
</Description>
            </Method>
            <Method>
               <Name>iGenGoToHome</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenGoToHome(obj, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% issue the command to move the rotator to home (0 deg Az, 0 Deg El)
IFace = get(obj, 'interface');
fprintf(IFace, '$00B0355E');
BufferReady = WaitforBuffer(IFace, 10);
if BufferReady
  out = fscanf(IFace, '%c');
  if strcmpi(out(end),'n')
    % Comm Error Nack
    if RaiseError
      % Comm Error Nack
      error('Rotator:Function:GoToHome:CommErr', 'Serial query returned no acknowledgement');
    end
  else % wait until it finishes moving
    Stopped = false;
    while ~Stopped
      fprintf(IFace, '$00B03059');
      BufferReady = WaitforBuffer(IFace, 5);
      if BufferReady
        out = fscanf(IFace, '%c');
        MovingAz = out(8);
        MovingEl = out(12);
        if strcmpi(MovingAz, 'S') &amp;&amp; strcmpi(MovingEl, 'S')
          Stopped = true;
        end
      else % break out of loop there is a propblem
        Stopped = true;
        if RaiseError
          error('Rotator:Function:GoToHome:CommError',...
            'There was an error reading the state of the rotator.');
        end
      end
    end
  end
  % Check to make sure the position has been set properly
  if ChkResult &amp;&amp; RaiseError
    CurrentAzPos = get(obj, 'iGenAzimuthPos');
    CurrentElPos = get(obj, 'iGenElevationPos');
    if ~WithinTol(CurrentAzPos, 0, .4, true) || ~WithinTol(CurrentElPos, 0, .4, true)
      error('Rotator:Function:GoToHome:SettingIncorrect',...
        ['The rotator position has not been set as requested. Currently at: ',...
        num2str(CurrentAzPos),' Deg Az, and ',num2str(CurrentElPos),' Deg El.']);
    end
  end
else
  if RaiseError
    error('Rotator:Function:GoToHome:TimeOutErr',...
      'There was a time out error. The rotator did not return any information.');
  end
end</MCode>
               </Code>
               <Description>This functions sends the rotator to 0 deg elevation and 0 degree azimuth.</Description>
            </Method>
            <Method>
               <Name>iGenMoveToPos</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenMoveToPos(obj, AzValDegrees, ElValDegrees, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end


IFace = get(obj, 'interface');
ItWorked = true;

% Get the azimuth and elevation scalars and offsets to convert the input
% degrees to the required ASCII Characters.
[AzOffset, AzScalar] = invoke(obj, 'GetOffSetAndScalar', 0);
if ~isempty(AzOffset) &amp;&amp; ~isempty(AzScalar)
  RawAZVal = round((AzValDegrees*AzScalar) + AzOffset);
  AzValHex = dec2hex(RawAZVal);
  [ElevOffset, ElevScalar] = invoke(obj, 'GetOffSetAndScalar', 1);
  if ~isempty(ElevOffset) &amp;&amp; ~isempty(ElevScalar)
    RawElVal = round((ElValDegrees*ElevScalar) + ElevOffset);
    ElValHex = dec2hex(RawElVal);
  else
    ItWorked = false;
  end
else
  ItWorked = false;
end

% Move the rotator the specified location.
if ItWorked
  CC = ComputeCheckSum(['$00B0210',AzValHex,'0',ElValHex]);
  fprintf(IFace, ['$00B0210',AzValHex,'0',ElValHex,CC]);
  BufferReady = WaitforBuffer(IFace, 5);
  if BufferReady
    out = fscanf(IFace, '%c');
    if strcmp(out(end),'n')
      if RaiseError
        % Comm Error Nack
        error('Rotator:Function:MoveToPos:CommErr', 'Serial query returned no acknowledgement');
      end
    else % wait until it finishes moving
      Stopped = false;
      while ~Stopped
        fprintf(IFace, '$00B03059');
        BufferReady = WaitforBuffer(IFace, 5);
        if BufferReady
          out = fscanf(IFace, '%c');
          MovingAz = out(8);
          MovingEl = out(12);
          if strcmpi(MovingAz, 'S') &amp;&amp; strcmpi(MovingEl, 'S')
            Stopped = true;
          end
        else % break out of loop there is a propblem
          Stopped = true;
          if RaiseError
            error('Rotator:Function:MoveToPos:CommError',...
              'There was an error reading the state of the rotator.');
          end
        end
      end
    end
  else
    if RaiseError
      error('Rotator:Function:GoToHome:TimeOutErr',...
        'There was a time out error. The rotator did not return any information');
    end
  end
  % Check to make sure the position has been set properly
  if ChkResult &amp;&amp; RaiseError
    CurrentAzPos = get(obj, 'iGenAzimuthPos');
    CurrentElPos = get(obj, 'iGenElevationPos');
    if ~WithinTol(CurrentAzPos, AzValDegrees, .4, true) || ~WithinTol(CurrentElPos, ElValDegrees, .4, true)
      error('Rotator:Function:MoveToPos:SettingIncorrect',...
        ['The rotator position has not been set as requested. Currently at: ',...
        num2str(CurrentAzPos),' Deg Az, and ',num2str(CurrentElPos),' Deg El.']);
    end
  end
else
  if RaiseError
    % Error reading offset and scalar values
    error('Rotator:Function:MoveToPos:CommErr', 'Unable to query scalar and offset values');
  end
end</MCode>
               </Code>
               <Description>This function moves the rotator to a specified azimuth and elevation.</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>