<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>C:\Program Files\MATLAB\R2009b\toolbox\instrument\instrument\drivers\RSMS4G_5To18GHzPresel.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Switch</InstrumentType>
   <InstrumentManufacturer>Sixnet</InstrumentManufacturer>
   <InstrumentModel>EtherTrak</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
% variable for E4440 Trigger Error Detector interface object
%global gTunFltTrk4440_IfaceObjE4440TrigErrDet

IOIP = get(obj, 'IOModuleIP');

% Initialize 33250A AWG
interface=get(obj,'interface');
set(interface,'InputBufferSize',12800000);
set(interface,'OutputBufferSize',12800000);
set(interface,'Timeout',10);
fclose(interface);

% Create Global interface object for the E4440 trigger Error Detector
% If an IP is selected create the TCPIP object.
 % IP of actual Error detector is 192.168.130.81
%gTunFltTrk4440_IfaceObjE4440TrigErrDet = instrfind('Type', 'tcpip', 'RemoteHost', IOIP, 'RemotePort', 502, 'Tag', '');
 
% Create the TCPIP object if it does not exist
% otherwise use the object that was found.
% if isempty(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
%   % IP of actual Error detector is 192.168.130.81
%   gTunFltTrk4440_IfaceObjE4440TrigErrDet = tcpip(IOIP, 502);
% else
%   fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet);
%   gTunFltTrk4440_IfaceObjE4440TrigErrDet = gTunFltTrk4440_IfaceObjE4440TrigErrDet(1);
% end
% 
% 
% set(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 'OutputBufferSize', 256);
% set(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 'InputBufferSize', 256);
% fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet);
% set(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 'ByteOrder', 'bigEndian');
% set(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 'Terminator', {'CR/LF','CR/LF'});
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
% global gTunFltTrk4440_IfaceObjE4440TrigErrDet
% 
% delete(gTunFltTrk4440_IfaceObjE4440TrigErrDet);
% clear global gTunFltTrk4440_IfaceObjE4440TrigErrDet</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>iGenHighestFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, ~, MaxFreq, ~, ~, ~] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');
propertyValue = MaxFreq{VCFPathNum+1};
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>18000000000</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Query the highest possible frequency for the currently active VCF Path.</Description>
            </Property>
            <Property>
               <Name>iGenInstDescID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
% global gTunFltTrk4440_IfaceObjE4440TrigErrDet
% 
% % get the IP address from the I/O module and append to YIG Tracker name
% out = get(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 'RemoteHost');
% idx = findstr(out, '.');
% propertyValue = ['YIG Tracker IP',out(idx(end):end)];
propertyValue = 'YIG Tracker 33250 only';</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>This property returns the name of the instrument. This name matches the name returned by getInstListAndDrivers.m.</Description>
            </Property>
            <Property>
               <Name>iGenInstError</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
% global gTunFltTrk4440_IfaceObjE4440TrigErrDet
% 
% fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet);
% pause(0.01)
% 
% % Modbus command to read 16 bit analog input
% [ErrorFlag, ~, ~] = ModbusAnalogRead(gTunFltTrk4440_IfaceObjE4440TrigErrDet,2, 1, 1);
% 
% if ~isempty(ErrorFlag)
%   % UNCOMMENT NEXT LINE AND REMOVE THE ONE THAT FOLLOWS IT FOR ACTUAL DRIVER CODE
%   Voltage = 5 * (ErrorFlag/32767);
%   %Voltage = 1.1*rand(); % This is for testing only. will occasionally simulate trigger glitch
%   if Voltage &gt; 1
%     propertyValue = 1;
%   else
%     propertyValue = 0;
%   end
% else
%   %report Exception
%   propertyValue = [];
% end
% 
% % Reset the error latch
% % turn on 1st Digital output of io142
% ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 1, 1)
% 
% % Turn output off again
% ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 1, 0)
% 
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
propertyValue = 0;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Queries the instrument for the error status if error has ocurred it returns a 1 if there is an error otherwise returns zero.
 If modbus errors ocurr the empty set will ber returned.</Description>
            </Property>
            <Property>
               <Name>iGenInstErrorRaiseError</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
% global gTunFltTrk4440_IfaceObjE4440TrigErrDet
% 
% fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet);
% pause(0.01)
% 
% % Modbus command to read 16 bit analog input
% [ErrorFlag, Success, ErrMsg] = ModbusAnalogRead(gTunFltTrk4440_IfaceObjE4440TrigErrDet,2, 1, 1);
% 
% if Success
%   Voltage = 5 * (ErrorFlag/32767);
%   if Voltage &gt; 1
%     propertyValue = 1;
%   else
%     propertyValue = 0;
%   end
% else
%   error('YIGTracker:Property:InstError:ModbusErr',ErrMsg);
% end
% 
% % Reset the error latch
% % turn on 1st Digital output of io142
% [Success, ErrMsg] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 1, 1)
% if ~Success
%   error('YIGTracker:Property:InstError:ModbusErr',ErrMsg);
% end
% 
% % Turn output off again
% [Success, ErrMsg] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 1, 0)
% if ~Success
%   error('YIGTracker:Property:InstError:ModbusErr',ErrMsg);
% end
% 
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
propertyValue = 0;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Queries the instrument for the error status if error has ocurred it returns a 1 if there is an error otherwise returns zero.

If modbus errors occur errors will be raised.</Description>
            </Property>
            <Property>
               <Name>iGenLowestFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, MinFreq, ~, ~, ~, ~] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');
propertyValue = MinFreq{VCFPathNum+1};</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>returns the lowest frequency for the currently set VCF Path.</Description>
            </Property>
            <Property>
               <Name>iGenMinimumBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, ~, ~, BW, ~, ~] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');
propertyValue = BW{VCFPathNum+1};</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>reads the minimum BW for the currently set VCF path.</Description>
            </Property>
            <Property>
               <Name>iGenNumPaths</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 6;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Specifies the possible number of VCF paths including no path.</Description>
            </Property>
            <Property>
               <Name>iGenStartFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
%   get the properties for all the 
interface = get(obj, 'interface');
[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');
LowVolt = str2double(query(interface, 'VOLT:LOW?'));
propertyValue = (LowVolt - CntrlOffset{VCFPathNum+1})/CntrlGain{VCFPathNum+1};</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
HighVolt = str2double(query(interface, 'VOLT:HIGH?'));
VCFPathNum = get(obj, 'iGenVCFPath');
% check to make sure frequency is in range
if propertyValue &gt;= MinFreq{VCFPathNum+1} &amp;&amp; propertyValue &lt;= MaxFreq{VCFPathNum+1}
  LowVolt = (CntrlGain{VCFPathNum+1}*propertyValue)+CntrlOffset{VCFPathNum+1};
  if HighVolt &gt;= (LowVolt + 0.002)
    fprintf(interface, ['VOLT:LOW ',num2str(LowVolt, '%10.6f')]);
    % if in stepped mode set high voltage 2mV greater than low voltage
    if ~get(obj, 'iGenSweepEnable')
      fprintf(interface, ['VOLT:HIGH ',num2str((LowVolt + 0.002), '%10.6f')]);
    end
  else % High Voltage must be 2 mV greater than low voltage
    fprintf(interface, ['VOLT:HIGH ',num2str((LowVolt + 0.002), '%10.6f')]);
    fprintf(interface, ['VOLT:LOW ',num2str(LowVolt, '%10.6f')]);
  end
else % input freq is out of range for VCF Path raise error.
  error(['The input frequency is invalid for the selected VCF Path. Acceptable values are between ',...
    num2str(MinFreq{VCFPathNum+1}/1e6), 'MHz and ',num2str(MaxFreq{VCFPathNum+1}/1e6),'MHz.']);
end
invoke(obj, 'iGenUpdateText');</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2e9</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets and gets the start frequency. When in stepped mode this is also the center frequency of the YIG.

IMPORTANT: Start freqeuncy will change the stop freqeuncy unless sweep is enabled. If both start and stop must be set,
the start freqeuncy must be set first follwed by the stop frequency or sweeping must be enabled before setting the 
start and stop frequencies.</Description>
            </Property>
            <Property>
               <Name>iGenStartFreqChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenStartFreq');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
HighVolt = str2double(query(interface, 'VOLT:HIGH?'));
VCFPathNum = get(obj, 'iGenVCFPath');

% check to make sure frequency is in range
if propertyValue &gt;= MinFreq{VCFPathNum+1} &amp;&amp; propertyValue &lt;= MaxFreq{VCFPathNum+1}
  LowVolt = (CntrlGain{VCFPathNum+1}*propertyValue)+CntrlOffset{VCFPathNum+1};
  if HighVolt &gt;= (LowVolt + 0.002)
    fprintf(interface, ['VOLT:LOW ',num2str(LowVolt, '%10.6f')]);
    % if in stepped mode set high voltage 2mV greater than low voltage
    if ~get(obj, 'iGenSweepEnable')
      fprintf(interface, ['VOLT:HIGH ',num2str((LowVolt + 0.002), '%10.6f')]);
    end
  else % High Voltage must be 2 mV greater than low voltage
    fprintf(interface, ['VOLT:HIGH ',num2str((LowVolt + 0.002), '%10.6f')]);
    fprintf(interface, ['VOLT:LOW ',num2str(LowVolt, '%10.6f')]);
  end
else
  error('YIGTraceker:Property:StartFreq:InvalidInput',...
    ['The input frequency is invalid for the selected VCF Path. Acceptable values are between ',...
    num2str(MinFreq{VCFPathNum+1}/1e6), 'MHz and ',num2str(MaxFreq{VCFPathNum+1}/1e6),'MHz.']);
end

% Check to make sure the start frequency was set as requested.
SetStartFreq = get(obj, 'iGenStartFreq');
if ~WithinTol(SetStartFreq, propertyValue, .1)
  error('YIGTracker:Property:StartFreq:SettingIncorrect',...
    'The start frequency of the YIG Tracker has not been set as requested');
end
invoke(obj, 'iGenUpdateText');</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2e9</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets and gets the start frequency. When in stepped mode this is also the center frequency of the YIG.

IMPORTANT: Start freqeuncy will change the stop freqeuncy unless sweep is enabled. If both start and stop must be set,
the start freqeuncy must be set first follwed by the stop frequency or sweeping must be enabled before setting the 
start and stop frequencies.

This property will check the set value to amke sure it is set as requested. If not set as requested an error will be raised.</Description>
            </Property>
            <Property>
               <Name>iGenStopFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

% Get properties for the current VCF Path to be used later
[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');

% calculate the stop voltage offset due to sweep time dilation.
TempHighVolt = str2double(query(interface, 'VOLT:HIGH?'));
LowVolt = str2double(query(interface, 'VOLT:LOW?'));
PulsePeriod = str2double(query(interface, 'PULS:PER?'));
SweepTime = get(obj, 'iGenSweepTime');
DeltaTime = PulsePeriod - SweepTime;
Slew = (TempHighVolt - LowVolt)/PulsePeriod;
DeltaV = Slew*DeltaTime;
HighVolt = TempHighVolt - DeltaV;

% convert the read back high voltage to the correct high freqeuncy
propertyValue = (HighVolt - CntrlOffset{VCFPathNum+1})/CntrlGain{VCFPathNum+1};</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');

% check to make sure frequency is in range
if propertyValue &gt;= MinFreq{VCFPathNum+1} &amp;&amp; propertyValue &lt;= MaxFreq{VCFPathNum+1}
  % Compute Voltage Delta for time dilation.
  LowVolt = str2double(query(interface, 'VOLT:LOW?'));
  PulsePeriod = str2double(query(interface, 'PULS:PER?'));
  HighVolt = (CntrlGain{VCFPathNum+1}*propertyValue)+CntrlOffset{VCFPathNum+1};
  SweepTime = get(obj, 'iGenSweepTime');
  DeltaTime = PulsePeriod - SweepTime;
  Slew = (HighVolt - LowVolt)/SweepTime;
  DeltaV = Slew*DeltaTime;
  if LowVolt &lt;= (HighVolt + DeltaV - 0.002)
    fprintf(interface, ['VOLT:HIGH ',num2str(HighVolt + DeltaV, '%10.6f')]);
  else % High voltage must be 2 mV greater than low voltage
    fprintf(interface, ['VOLT:LOW ',num2str((HighVolt + DeltaV - 0.002), '%10.6f')]);
    fprintf(interface, ['VOLT:HIGH ',num2str(HighVolt + DeltaV, '%10.6f')]);
  end
else
  error('YIGTraceker:Property:StopFreq:InvalidInput',...
    ['The input frequency is invalid for the selected VCF Path. Acceptable values are between ',...
    num2str(MinFreq{VCFPathNum+1}/1e6), 'MHz and ',num2str(MaxFreq{VCFPathNum+1}/1e6),'MHz.']);
end
invoke(obj, 'iGenUpdateText');</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This function sets and gets the Stop Frequency.

IMPORTANT: Start freqeuncy will change the stop freqeuncy unless sweep is enabled. If both start and stop must be set,
the start freqeuncy must be set first follwed by the stop frequency or sweeping must be enabled before setting the 
start and stop frequencies.</Description>
            </Property>
            <Property>
               <Name>iGenStopFreqChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenStopFreq');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
[~, MinFreq, MaxFreq, ~, CntrlGain, CntrlOffset] = invoke(obj, 'iGenReadVCFProps');
VCFPathNum = get(obj, 'iGenVCFPath');

% check to make sure frequency is in range
if propertyValue &gt;= MinFreq{VCFPathNum+1} &amp;&amp; propertyValue &lt;= MaxFreq{VCFPathNum+1}
  % Compute Voltage Delta for time dilation.
  LowVolt = str2double(query(interface, 'VOLT:LOW?'));
  PulsePeriod = str2double(query(interface, 'PULS:PER?'));
  HighVolt = (CntrlGain{VCFPathNum+1}*propertyValue)+CntrlOffset{VCFPathNum+1};
  SweepTime = get(obj, 'iGenSweepTime');
  DeltaTime = PulsePeriod - SweepTime;
  Slew = (HighVolt - LowVolt)/SweepTime;
  DeltaV = Slew*DeltaTime;
  if LowVolt &lt;= (HighVolt + DeltaV - 0.002)
    fprintf(interface, ['VOLT:HIGH ',num2str(HighVolt + DeltaV, '%10.6f')]);
  else % High voltage must be 2 mV greater than low voltage
    fprintf(interface, ['VOLT:LOW ',num2str((HighVolt + DeltaV - 0.002), '%10.6f')]);
    fprintf(interface, ['VOLT:HIGH ',num2str(HighVolt + DeltaV, '%10.6f')]);
  end
else
  error('YIGTraceker:Property:StopFreq:InvalidInput',...
    ['The input frequency is invalid for the selected VCF Path. Acceptable values are between ',...
    num2str(MinFreq{VCFPathNum+1}/1e6), 'MHz and ',num2str(MaxFreq{VCFPathNum+1}/1e6),'MHz.']);
end

% check the setting to make sure it was set properly.
SetStopFreq = get(obj, 'iGenStopFreq');
if ~WithinTol(SetStopFreq, propertyValue, .1)
  error('YIGTracker:Property:StopFreq:SettingIncorrect',...
    'The stop frequency of the YIG Tracker has not been set as requested');
end
% update the 33250 display
invoke(obj, 'iGenUpdateText');</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This function sets and gets the Stop Frequency.

IMPORTANT: Start freqeuncy will change the stop freqeuncy unless sweep is enabled. If both start and stop must be set,
the start freqeuncy must be set first follwed by the stop frequency or sweeping must be enabled before setting the 
start and stop frequencies.

This property will check the set value to amke sure it is set as requested. If not set as requested an error will be raised.</Description>
            </Property>
            <Property>
               <Name>iGenSweepable</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 1;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>returns whether or not instrument is sweepable</Description>
            </Property>
            <Property>
               <Name>iGenSweepEnable</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
Trig = deblank(query(interface, 'TRIG:SOUR?'));
if strcmpi(Trig, 'EXT')
  propertyValue = 1;
elseif strcmpi(Trig, 'BUS')
  propertyValue = 0;
else % an error has ocurred
  propertyValue = [];
end
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

if propertyValue == 1
  fprintf(interface, 'TRIG:SOUR EXT');
elseif propertyValue == 0
  fprintf(interface, 'TRIG:SOUR BUS');
end
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or gets whether or not sweeping is enabled. This is done with the trigger.
Bus = not sweepable
External = sweepable

The property will return a 1 if sweeping is enabled and a 0 if it is not.</Description>
            </Property>
            <Property>
               <Name>iGenSweepEnableChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepEnable');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

if propertyValue == 1
  fprintf(interface, 'TRIG:SOUR EXT');
elseif propertyValue == 0
  fprintf(interface, 'TRIG:SOUR BUS');
end

% Check to make sure the property was set correctly
SetSE = get(obj, 'iGenSweepEnable');
if SetSE ~= propertyValue
  error('YIGTracker:Property:SweepEnable:SettingIncorrect',...
    'The sweep enable feature of the YIG Tracker has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or gets whether or not sweeping is enabled. This is done with the trigger.
Bus = not sweepable
External = sweepable

The property will return a 1 if sweeping is enabled and a 0 if it is not.</Description>
            </Property>
            <Property>
               <Name>iGenSweepTime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
PulsePeriod = str2double(query(interface, 'PULS:PER?'));
if PulsePeriod &lt;= (1.0085294 * 10) + 0.0000414707
  propertyValue = (PulsePeriod - 0.0000414707)/1.0085294;
else
  propertyValue = PulsePeriod - (0.085294 + 0.0000414707);
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

FStart = get(obj, 'iGenStartFreq');
FStop = get(obj, 'iGenStopFreq');

if propertyValue &lt;= 10
  PulsePeriod = (1.0085294 * propertyValue) + 0.0000414707;
else
  PulsePeriod = propertyValue + (0.085294 + 0.0000414707);
end

BandNum = invoke(obj, 'iGenCheckInBand', FStart, FStop, false);
if ~isempty(BandNum)
  if BandNum == 0
    PulseDelay = 0;
  else
    PulseDelay = ((0.00033 * ((FStart / 1e9) - 2.85)) + 0.00048);
  end
else
  error('YIGTraceker:Property:SweepTime:InvalidInput',...
    'The start and stop frequencies must not be set such that they cross an E4440 band edge.');
end
fprintf(interface, ['PULS:PER ',num2str(PulsePeriod, '%.6f')]);
fprintf(interface, ['TRIG:DEL ',num2str(PulseDelay, '%.5f')]);
set(obj,'iGenStopFreq',FStop); % UpdateText will be called by StopFreq
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1975.0" Min="0.01"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.01</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the sweep time. Start and Stop freqs must be set beforehand.</Description>
            </Property>
            <Property>
               <Name>iGenSweepTimeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepTime');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');

FStart = get(obj, 'iGenStartFreq');
FStop = get(obj, 'iGenStopFreq');

if propertyValue &lt;= 10
  PulsePeriod = (1.0085294 * propertyValue) + 0.0000414707;
else
  PulsePeriod = propertyValue + (0.085294 + 0.0000414707);
end

BandNum = invoke(obj, 'iGenCheckInBand', FStart, FStop, false);
if ~isempty(BandNum)
  if BandNum == 0
    PulseDelay = 0;
  else
    PulseDelay = ((0.00033 * ((FStart / 1e9) - 2.85)) + 0.00048);
  end
else
  error('YIGTraceker:Property:SweepTime:InvalidInput',...
    'The start and stop freqeuncies must not be set such that they cross an E4440 band edge.');
end
fprintf(interface, ['PULS:PER ',num2str(PulsePeriod, '%.6f')]);
fprintf(interface, ['TRIG:DEL ',num2str(PulseDelay, '%.5f')]);

% check to make sure it was set properly
SetST = get(obj, 'iGenSweepTime');
if ~WithinTol(SetST, propertyValue, .1)
  error('YIGTracker:Property:SweepTime:SettingIncorrect',...
    'The sweep time of the YIG Tracker has not been set as requested');
end

% Set the stop frequency again since it is dependent on sweep time.
set(obj,'iGenStopFreq',FStop); % UpdateText will be called by StopFreq</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1975.0" Min="0.01"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.01</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the sweep time. Start and Stop freqs must be set beforehand.

This property will check to see if the sweep time has been set as requested.
If not it wil raise an error.</Description>
            </Property>
            <Property>
               <Name>iGenVCFPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
global gE4440YIGTracker_VCFPath

propertyValue = gE4440YIGTracker_VCFPath;

% fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
% % read input path module 1 output states
% [VCFVect, Success, ErrMsg] = ModbusDigitalRead(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 2, 5)
% 
% temp = find(VCFVect == 1);
% if isempty(temp)
%   propertyValue = 0;
% elseif length(temp) == 1;
%   propertyValue = temp;
% else % an error occurred an improper path has been set
%   propertyValue = [];
% end
% 
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
global gE4440YIGTracker_VCFPath

%fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
% convert string to double if input is a string
if ischar(propertyValue)
    propertyValue = str2double(propertyValue);
end
gE4440YIGTracker_VCFPath = propertyValue;

% Turn off all paths before turning the desired one 
% VCFVect = zeros(1,5);
% if propertyValue &gt;= 1 &amp;&amp; propertyValue &lt;= 5
%   VCFVect(propertyValue) = 1;
% end
% 
% % write to modbus device
% [Success, ErrMsg] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 2, VCFVect)
% % switch driver voltage path
% if propertyValue == 3
%   [Success1, ErrMsg1] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 16, 1)
% else
%   [Success1, ErrMsg1] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 16, 0)
% end
% 
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="NF 218" Value="1"/>
                     <Enum Name="TMF1800J" Value="2"/>
                     <Enum Name="RSMS4G 0.5-2 GHz" Value="3"/>
                     <Enum Name="RSMS4G 2-18 GHz" Value="4"/>
                     <Enum Name="RSMS4G 18-26.5 GHz" Value="5"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the VCF path as specified by the argument "PathVal", where the value
can be any value from 0 to (Number of paths).  A value of 0 designates that no VCF Path is selected.
Digital outputs on the io142 are set to keep track of what VCF path is selected.
0 = no VCF
1 = NF_218
2 = TMF1800J
3 = Presel4G_p5_18.8   .5-2 GHz tunable YIG in RSMS4G .5-18GHz Preselector
4 = Presel4G_p5_18.9   2-18 GHz tunable YIG in RSMS4G .5-18GHz Preselector
5 = Presel4G_18_26.3   YIG in RSMS4G 18-26.5GHz Preselector</Description>
            </Property>
            <Property>
               <Name>iGenVCFPathChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenVCFPath');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
global gE4440YIGTracker_VCFPath

% fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet)

% convert string to double if input is a string
if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

gE4440YIGTracker_VCFPath = propertyValue;
% Turn off all paths before turning the desired one
% VCFVect = zeros(1,5);
% if propertyValue &gt;= 1 &amp;&amp; propertyValue &lt;= 5
%   VCFVect(propertyValue) = 1;
% end
% 
% % write to modbus device
% [Success, ErrMsg] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 2, VCFVect)
% 
% if Success
% % switch driver voltage path
%   if propertyValue == 3
%     [Success1, ErrMsg1] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 16, 1)
%   else
%     [Success1, ErrMsg1] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 16, 0)
%   end
%   if ~Success1
%     error('YIGTracker:Property:VCFPath:ModbusErr',ErrMsg1);
%   end
% else
%   error('YIGTracker:Property:VCFPath:ModbusErr',ErrMsg);
% end
% 
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
% 
% % check to make sure the property was set correctly
% SetVCFPath = get(obj, 'iGenVCFPath');
% if SetVCFPath ~= propertyValue
%   error('YIGTracker:Property:VCFPath:SettingIncorrect',...
%     'The VCF path of the YIG Tracker has not been set as requested');
% end
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="NF 218" Value="1"/>
                     <Enum Name="TMF1800J" Value="2"/>
                     <Enum Name="RSMS4G 0.5-2 GHz" Value="3"/>
                     <Enum Name="RSMS4G 2-18 GHz" Value="4"/>
                     <Enum Name="RSMS4G 18-26.5 GHz" Value="5"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the VCF path as specified by the argument "PathVal", where the value
can be any value from 0 to (Number of paths).  A value of 0 designates that no VCF Path is selected.
Digital outputs on the io142 are set to keep track of what VCF path is selected.
0 = no VCF
1 = NF_218
2 = TMF1800J
3 = Presel4G_p5_18.8   .5-2 GHz tunable YIG in RSMS4G .5-18GHz Preselector
4 = Presel4G_p5_18.9   2-18 GHz tunable YIG in RSMS4G .5-18GHz Preselector
5 = Presel4G_18_26.3   YIG in RSMS4G 18-26.5GHz Preselector

This property checks to make sure it was set properly; if not an error is raised.</Description>
            </Property>
            <Property>
               <Name>IOModuleIP</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
% global gTunFltTrk4440_IOModuleIPAddress
% propertyValue = gTunFltTrk4440_IOModuleIPAddress;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
% global gTunFltTrk4440_IOModuleIPAddress
% gTunFltTrk4440_IOModuleIPAddress = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>This property is only used for passing the IP address of the trigger glitch
detector I/O module to the driver. It should only be used when creating the 
device object using the icdevice command when connecting to the instrument.</Description>
            </Property>
            <Property>
               <Name>IPAddress</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
%global gTunFltTrk4440_IfaceObjE4440TrigErrDet

% get the IP address from the I/O module and append to YIG Tracker name
propertyValue = 10;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the I/O module IP address as read from the device.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>iGenCheckInBand</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function BandNum = iGenCheckInBand(obj, fStart, fStop, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% set optional input RaiseError if it doesn't exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% determine if start and stop fit into E4440 band.
if fStart &gt;= 30 &amp;&amp; fStop &lt;= 3.05e9
  BandNum = 0;
elseif fStart &gt;= 2.85e9 &amp;&amp; fStop &lt;= 6.6e9
  BandNum = 1;
elseif fStart &gt;= 6.2e9 &amp;&amp; fStop &lt;= 13.2e9
  BandNum = 2;
elseif fStart &gt;= 12.8e9 &amp;&amp; fStop &lt;= 19.2e9
  BandNum = 3;
elseif fStart &gt;= 18.7e9 &amp;&amp; fStop &lt;= 26.5e9
  BandNum = 4;
else
  if RaiseError   % Raise Error frequency range does not fit in band
    error('YIGTracker:Function:CheckInBand:NotInBand',...
      'The input start and stop frequencies do not fit within an E4440 band.')
  else
    BandNum = [];
  end
end
  </MCode>
               </Code>
               <Description>This function checks to see if a selected frequency range fits within an E4440 frequency band
returns an integer corresponding to the band the range does fit in.

0 = 30 Hz - 3.05 GHz
1 = 2.85 - 6.6 GHz
2 = 6.2 - 13.2 GHz
3 = 12.8 - 19.2 GHz
4 = 18.7 - 26.5 GHz

If it does not fit the empty set is returned unless RaiseError = true in which
case an error will be raised.</Description>
            </Method>
            <Method>
               <Name>iGenInit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenInit(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
global gE4440YIGTracker_VCFPath
%fopen(gTunFltTrk4440_IfaceObjE4440TrigErrDet)

% turn off all outputs on Sixnet Ethertrak 16D01-H
% [Success, ErrMsg] = ModbusDigitalWrite(gTunFltTrk4440_IfaceObjE4440TrigErrDet, 1, 1, zeros(1,16));
% fclose(gTunFltTrk4440_IfaceObjE4440TrigErrDet)
% if ~Success &amp;&amp; RaiseError
%   error('YIGTracker:Function:Init:ModbusErr',['A modbus error occurred: ',ErrMsg]);
% end
gE4440YIGTracker_VCFPath = 0;

% Set Up 33250A
interfaceObj = get(obj, 'interface');
fprintf(interfaceObj, '*RST'); % instrument preset 33250
fprintf(interfaceObj, 'OUTP:LOAD INF'); % High Z Output impedance
fprintf(interfaceObj, 'FUNC RAMP'); % Set ramp funciton
ST = (1.0085294*.01)+.0000414707;
fprintf(interfaceObj, ['PULS:PER ',num2str(ST,'%.6f')]); %Set ramp pulse period to 10ms
fprintf(interfaceObj, 'VOLT:LOW 0'); % Set Lo-level to 0 volts
fprintf(interfaceObj, 'VOLT:HIGH 10'); % set Hi-level 10 Volts
fprintf(interfaceObj, 'BURS:MODE TRIG'); % Set burst mode to triggered
fprintf(interfaceObj, 'TRIG:SOUR BUS'); % Set trigger type to Bus, disable external trigger
fprintf(interfaceObj, 'BURS:PHAS -179.9'); % set start burst phase to -179.9 deg
fprintf(interfaceObj, 'BURS:STAT ON'); % Turn burst on
fprintf(interfaceObj, 'OUTP ON'); % Turn on output
fprintf(interfaceObj, 'DISP:TEXT "YIG Tracker Mode"');
</MCode>
               </Code>
               <Description>This subroutine resets all digital outputs on the IOTech modules, puting the YIG Tracker in an initial
state with no active VCF paths, start or stop freqeuncies.</Description>
            </Method>
            <Method>
               <Name>iGenNumSweptFreqBands</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinFreqs, MaxFreqs] = iGenNumSweptFreqBands(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
MinFreqs(1) = 30; 
MaxFreqs(1) = 3.05e9;
MinFreqs(2) = 2.85e9; 
MaxFreqs(2) = 6.6e9;
MinFreqs(3) = 6.2e9; 
MaxFreqs(3) = 13.2e9;
MinFreqs(4) = 12.8e9; 
MaxFreqs(4) = 19.2e9;
MinFreqs(5) = 18.7e9; 
MaxFreqs(5) = 26.5e9;</MCode>
               </Code>
               <Description>queries the band limits for all the E4440 Bands
the length of the returned vector is the number of available bands.</Description>
            </Method>
            <Method>
               <Name>iGenReadVCFProps</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [VCFName, MinFreq, MaxFreq, MinBW, CntrlGain, CntrlOffset] = iGenReadVCFProps(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
VCFName{1} = 'None';
MinFreq{1} = 0;
MaxFreq{1} = 0;
MinBW{1} = 0;
CntrlGain{1} = 0;
CntrlOffset{1} = 0;

VCFName{2} = 'NF 218';
MinFreq{2} = 1900e6;
MaxFreq{2} = 18777.5e6;
MinBW{2} = 40e6;
CntrlGain{2} = 0.5e-9;
CntrlOffset{2} = 0;

VCFName{3} = 'TMF1800J';
MinFreq{3} = 1900e6;
MaxFreq{3} = 18777.5e6;
MinBW{3} = 40e6;
CntrlGain{3} = 0.5e-9;
CntrlOffset{3} = 0;

VCFName{4} = 'RSMS4G 0.5-2 GHz';
MinFreq{4} = 425e6;
MaxFreq{4} = 2030e6;
MinBW{4} = 20e6;
CntrlGain{4} = 6e-9;
CntrlOffset{4} = -2.5;

VCFName{5} = 'RSMS4G 2-18 GHz';
MinFreq{5} = 1900e6;
MaxFreq{5} = 18270e6;
MinBW{5} = 40e6;
CntrlGain{5} = 0.5e-9;
CntrlOffset{5} = 0;

VCFName{6} = 'RSMS4G 18-26.5 GHz';
MinFreq{6} = 17900e6;
MaxFreq{6} = 26897.5e6;
MinBW{6} = 50e6;
CntrlGain{6} = 1e-9;
CntrlOffset{6} = -17;</MCode>
               </Code>
               <Description>returns the properties for the VCF paths 
index = filter type
1 = no VCF
2 = NF_218
3 = TMF1800J
4 = Presel4G_p5_18.8   .5-2 GHz tunable YIG in RSMS4G .5-18GHz Preselector
5 = Presel4G_p5_18.9   2-18 GHz tunable YIG in RSMS4G .5-18GHz Preselector
6 = Presel4G_18_26.3   YIG in RSMS4G 18-26.5GHz Preselector</Description>
            </Method>
            <Method>
               <Name>iGenSetVCFPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetVCFPath(obj, PreselModel, FStop, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Create optional variables if they aren;t input
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

ItWorked = true;
switch PreselModel
  case 'None'
    VCFPathNum = 0;
  case 'RSMS4G 18-26GHz'
    VCFPathNum = 5;   
  case 'RSMS4G 0.5-18GHz'
    if FStop &lt;= 2.03e9
      VCFPathNum = 3;
    else
      VCFPathNum = 4;
    end    
  case 'NF 218'
    VCFPathNum = 1;
  case 'TMF1800J'
    VCFPathNum = 2;
  otherwise
    ItWorked = false;
    if RaiseError
      error('YIGTracker:Function:SetVCFPath:InvlaidInput',...
        'Input Preselector model name is invalid. Allowed names are: None, RSMS4G 0.5-18GHz, RSMS4G 18-26GHz, TMF1800J, or NF 218.');
    end
end

%if valid input selected set it
if ItWorked
  set(obj, 'iGenVCFPath', VCFPathNum);
  if RaiseError &amp;&amp; ChkResult
    % check to make sure VCF path was set properly
    SetVCFPath = get(obj, 'iGenVCFPath');
    if SetVCFPath ~= VCFPathNum
      error('YIGTracker:Function:SetVCFPath:SettingIncorrect',...
        'The VCF path of the YIG tracker was not set as requested.');
    end
  end
end</MCode>
               </Code>
               <Description>sets the path based on preselector model name and stop freqeuncy.

If ChkResult = RaiseError = 1 then the setting will be checked and 
an error will be raised if it is not set properly.</Description>
            </Method>
            <Method>
               <Name>iGenSetYIGTracker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetYIGTracker(obj, FStart, FStop, ST, SweepEnabled, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Create optional variables if they aren;t input
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

%set the instrument
if ChkResult &amp;&amp; RaiseError
  set(obj, 'iGenSweepEnableChkResult', SweepEnabled);
  set(obj, 'iGenStartFreqChkResult', FStart);
  set(obj, 'iGenStopFreqChkResult', FStop);
  set(obj, 'iGenSweepTimeChkResult', ST);
else
  set(obj, 'iGenSweepEnable', SweepEnabled);
  set(obj, 'iGenStartFreq', FStart);
  set(obj, 'iGenStopFreq', FStop);
  set(obj, 'iGenSweepTime', ST);
end</MCode>
               </Code>
               <Description>This command set the YIG tracker given the appropriate inputs
Model Name must match that given by instrument query InstDescID
Fstart, FStop, SweepTime
Sweeping set whather or not sweep should be enabled
This command is useful for measurements.
Allows for single command to set up TunFltTrk4440

Returns boolean indicating whether or not it sucessfully set up the YIG Tracker

VCF Path must be set before this is called.</Description>
            </Method>
            <Method>
               <Name>iGenUpdateText</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenUpdateText(obj)
% % For group functions, OBJ is the group object. For
% % base device functions, OBJ is the device object.
% interface = get(obj, 'interface');
% SweepTime = get(obj, 'iGenSweepTime');
% HighFreq = get(obj, 'iGenStopFreq');
% LowFreq = get(obj, 'iGenStartFreq');
% if LowFreq &gt;= 1e9
%   lowscalar = 1e9;
%   lowformStr = '%.3f';
%   lowunitStr = 'GHz';
% else
%   lowscalar = 1e6;
%   lowformStr = '%.1f';
%   lowunitStr = 'MHz';
% end
% if HighFreq &gt;= 1e9
%   highscalar = 1e9;
%   highformStr = '%.3f';
%   highunitStr = 'GHz';
% else
%   highscalar = 1e6;
%   highformStr = '%.1f';
%   highunitStr = 'MHz';
% end
% if SweepTime &lt; 1
%   TimeScalar = 1e-3;
%   TimeUnitStr = 'ms';
%   TimeFormStr = '%3.0f';
% elseif SweepTime &gt;= 1 &amp;&amp; SweepTime &lt; 1000
%   TimeScalar = 1;
%   TimeUnitStr = 's';
%   TimeFormStr = '%2.1f';
% else
%   TimeScalar = 1e3;
%   TimeUnitStr = 'ks';
%   TimeFormStr = '%4.0f';
% end
% fprintf(interface, ['DISP:TEXT "F1=',num2str(LowFreq/lowscalar,lowformStr),...
%   lowunitStr,', F2=',num2str(HighFreq/highscalar,highformStr),highunitStr,', ST=',...
%   num2str(SweepTime/TimeScalar,TimeFormStr),TimeUnitStr,'"']);
</MCode>
               </Code>
               <Description>Updates the text on the front panel of the 33250 to indicate start freq stop freq VCF Path and sweep time</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>