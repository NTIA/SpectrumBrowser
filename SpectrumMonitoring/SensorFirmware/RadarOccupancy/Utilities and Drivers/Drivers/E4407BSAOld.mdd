<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>1.0</FileVersion>
   <DriverName>C:\Program Files\MATLAB\R2006b\work\IQ_Analyzer_v3.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Vector Analyzer</InstrumentType>
   <InstrumentManufacturer>Agilent Technologies Inc.</InstrumentManufacturer>
   <InstrumentModel>E4440A</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify>*IDN?</Identify>
   <Reset>*RST</Reset>
   <Selftest>*TST?</Selftest>
   <Error>System:Error?</Error>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
set(interface,'InputBufferSize',1e6);
set(interface,'Timeout',10);
set(interface,'ByteOrder','bigEndian');
fclose(interface);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>InstrumentCommand</Type>
   </ConnectInitCode>
   <CleanupCode>
      <Type>InstrumentCommand</Type>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>ADCRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue/>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Annotation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DISP:ENAB</ConfigureCommand>
                     <QueryCommand>DISP:ENAB?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>On</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Turns the scrren annotation on or off</Description>
            </Property>
            <Property>
               <Name>ApplyAmpCorr</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CORR:CSET:ALL</ConfigureCommand>
                     <QueryCommand>CORR:CSET:ALL?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Atten</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:ATT</ConfigureCommand>
                     <QueryCommand>:POW:ATT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="70.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the input attenuation in dB...

2.1.2 Attenuation
Allows you to adjust the input attenuation. Press Atten Step to set the attenuation step so
that attenuation will change in 2 dB or 10 dB increments. The analyzer input attenuator
reduces the power level of the input signal delivered to the input mixer. If set manually,
the attenuator is recoupled when Attenuation (Auto) is selected. To enter a value below 6 dB,
you must use the front-panel numeric keypad.
Attenuation is coupled to Reference Level, so adjusting the Reference Level may change
the Attenuation. The analyzer selects an Attenuation setting that is as small as possible
while keeping the Ref Level at or below the Max Mixer Lvl setting. The current value is
indicated by Atten at the top of the display. A # appears in front of Atten when Attenuation
(Man) is selected.
CAUTION To prevent damage to the input mixer, do not exceed a power level of +30 dBm
at the input.
To prevent signal compression, keep the power at the input mixer below 0
dBm (10 MHz - 200 MHz), below 3 dBm (200 MHz - 6.6 GHz), and below
–2 dBm (6.6 GHz - 50.0 GHz). With the attenuator set to Auto, a signal at or
below the reference level results in a mixer level at or below −10 dBm.
Key Path: AMPLITUDE / Y Scale
State Saved: Saved in Instrument State
Factory Preset: Auto Coupled, 10 dB (for external amplifier gain of 0 dB)
Resolution/Rounding/
Truncation: The attenuation is resolved to 2 dB increments. If the value is at least
0.5 dB over a value, then the next higher value is selected. Therefore, 10.4
selects 10, while 10.5 selects 12.
Range: 0 dB to 70 dB
Chapter 2 37
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
Remote Command:
[:SENSe]:POWer[:RF]:ATTenuation &lt;rel_power&gt;
[:SENSe]:POWer[:RF]:ATTenuation?
[:SENSe]:POWer[:RF]:ATTenuation:AUTO OFF|ON|0|1
[:SENSe]:POWer[:RF]:ATTenuation:AUTO?
Remote Command Notes: . The Reference Level setting may be affected when the
Attenuation is changed. See Ref Level.
Example:. POW:ATT 30
POW:ATT?
POW:ATT:AUTO ON
POW:ATT:AUTO?</Description>
            </Property>
            <Property>
               <Name>AutoCal</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
propertyValue = query(interface, 'CAL:AUTO?')</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface')
if strncmpi('ALERT', propertyValue, 4) || strncmpi('OFF', propertyValue, 3)
  fprintf(interface, 'CAL:AUTO 0')
  if strncmpi('ALERT', propertyValue, 4)
    % warn that e4407 does not have alert mode
  end
else
  fprintf(interface, 'CAL:AUTO 1')
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="Alert" Value="ALERT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>On</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>4.9.4.1 Auto Align
Allows you to turn the instrument automatic alignment On or Off. or select Alert to be
alerted that alignments are needed.
• Off, the instrument won’t initiate any* visible alignments or alerts.
• All, turns on the automatic alignment of all measurement systems. When Auto Align, All
is selected, “AA” appears along the left edge of the display.
• Alert, a 3 degree (Celsius) temperature change or a time span of 24 hours since the last
successful Full alignment (e.g., Align All Now) will trigger an alert that alignments
need to be done, but no alignments will be performed without user input. When Auto
Align Alert is selected “AL” appears along the left edge of the display.
• All but RF, turns on the automatic alignment of all measurement systems except the RF
section. (Eliminating automatic alignment of the RF prevents changes in the input
impedance between sweeps, which could cause input device instability.) When Auto
Align, All but RF is selected, “AB” appears along the left edge of the display.
262 Chapter 4
Instrument Functions: P - Z
System
Instrument Functions: P - Z
• On, the instrument behaves like the Alert, but will automatically perform a full
alignment when it is needed. In addition, every 15 minutes passing or 1.5 degrees
temperature change will cause just the RF system gain to be aligned, to achieve the best
absolute amplitude accuracy. For either alignment, the instrument will stop any
measurement currently in process, perform the full alignment, then restart the
measurement from the beginning (similar to pressing Restart). If any alignment FAILs
or is ABORTed by the user (eg ESCape key), the instrument will wait 5 minutes before
retrying the necessary alignment. This helps to avoid infinite recursive loops of
alignment behavior in the event of broken hardware. Also see “Align All Now” on
page 262.
There are 2 very quick alignments, invisible to the user, that are done every few minutes
or when certain settings are changed. These still occur, even if AutoAlign is set to Off.
These alignments are the Current SysGain and Current IF Flatness methods which can
also be forced to occur by user under the Align Subsys menu.
Key Path: System, Alignments
State Saved: Survives Preset and power cycle, but not saved in Instrument State.
Factory Preset: Not affected by Preset.
Factory
Default: On (Restored by System, Restore Sys Defaults.)
Remote Command:
:CALibration:AUTO OFF|ON|ALERt
:CALibration:AUTO?
Example: CAL:AUTO ON</Description>
            </Property>
            <Property>
               <Name>AvgMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CHP:AVER:TCON</ConfigureCommand>
                     <QueryCommand>CHP:AVER:TCON?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Exponential" Value="EXP"/>
                     <Enum Name="Repeat" Value="REP"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>EXP</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>AVGTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>BPOW:AVER:TYPE</ConfigureCommand>
                     <QueryCommand>BPOW:AVER:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Log-Pwr" Value="LPOW"/>
                     <Enum Name="RMS" Value="POW"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Log-Pwr</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>ByteOrder</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FORM:BORD</ConfigureCommand>
                     <QueryCommand>FORM:BORD?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Normal" Value="NORM"/>
                     <Enum Name="Swapped" Value="SWAP"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the byte order of the analyzer.
Use Normal for Motorola processors
Use Swapped for PCs</Description>
            </Property>
            <Property>
               <Name>CarrierTrackState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>CenterFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:CENT</ConfigureCommand>
                     <QueryCommand>:FREQ:CENT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Activates the function that sets the center of the displayed frequency range to the specified
frequency.</Description>
            </Property>
            <Property>
               <Name>CFStepSize</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FREQ:CENT:STEP</ConfigureCommand>
                     <QueryCommand>FREQ:CENT:STEP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the center frequency step size</Description>
            </Property>
            <Property>
               <Name>DANLMethod</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>DataFormat</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FORM</ConfigureCommand>
                     <QueryCommand>FORM?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ASCII" Value="ASC"/>
                     <Enum Name="UINT 16" Value="UINT,16"/>
                     <Enum Name="INT 32" Value="INT, 32"/>
                     <Enum Name="REAL 32" Value="REAL, 32"/>
                     <Enum Name="REAL 64" Value="REAL, 64"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ASCII</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the format of the trace data</Description>
            </Property>
            <Property>
               <Name>Detector</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DET</ConfigureCommand>
                     <QueryCommand>:DET?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Average" Value="AVER"/>
                     <Enum Name="Negative" Value="NEG"/>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Sample" Value="SAMP"/>
                     <Enum Name="RMS" Value="RMS"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Average</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the detector type

NOTE:  QP will only work with the PSA

2.4.1 Detector
Select a specific type of detector, or choose Auto to let the instrument select the appropriate
detector for a particular measurement.
When discussing detectors, it is important to understand the concept of a trace “bucket.”
For every trace point displayed in swept and zero-span analysis, there is a finite time
during which the data for that point is collected. The analyzer has the ability to look at all
of the data collected during that time and present a single point of trace data based on the
detector mode. We call the interval during which the data for that trace point is being
collected, the “bucket.” The data is sampled rapidly enough within a “bucket” that it must
be reduced in some fashion to yield a single data point for each bucket. There are a number
of ways to do this and which way is used depends on the detector selected. Details on how
each detector does this are presented below.
In FFT analysis, the bucket represents just a frequency interval. The detector in an FFT
mode determines the relationship betgween the spectrum computed by the FFT and the
single data point displayed for the bucket.
When the Detector choice is Auto, the detector selected depends on marker functions, trace
functions, and the trace averaging function.
See “Auto Rules For Detector Selection” on page 88 for information on the Auto detector
selection.
When you manually select a detector (instead of selecting Auto), that detector is used
regardless of other analyzer settings.
The detector choices are:
• Normal − displays the peak of CW-like signals and maximums and minimums of
noise-like signals.
• Average − displays the average of the signal within the bucket. The averaging method
depends upon Avg Type selection (voltage, power or log scales).
• Peak − displays the maximum of the signal within the bucket.
• Sample − displays the instantaneous level of the signal at the center of the bucket
represented by each display point.
• Negative Peak − displays the minimum of the signal within the bucket.
• Quasi Peak − a fast-rise, slow-fall detector used in making CISPR compliant EMI
measurements.
• EMI Average − displays the instantanewous level of the signal at the center of the
bucket, just like the sample detector. Also changes the auto coupling of VBW, RBW and
86 Chapter 2
Instrument Functions: A - L
Det/Demod
Instrument Functions: A - L
Avg/VBW Type and the set of available RBWs. Used in making CISPR-compliant
measurements.
• EMI Peak − the same as the Peak detector but uses CISPR related bandwidths.
• MIL Peak − the same as the Peak detector but uses MIL related bandwidths.
Because they may not find the true peak of a spectral component, neither average nor
sample detectors measure amplitudes of CW signals as accurately as peak or normal, but
they do measure noise without the biases of peak detection.
The detector in use is indicated on the left side of the display, just below Reference level.
The designators are:
• Norm − Normal detector
• Avg − Average detector
• Peak − Peak detector
• Samp − Sample detector
• NPk − Negative Peak detector
• EmiQP − Quasi Peak detector
• EmiAv − ΕMI Average detector
• EmiPk − Peak detector with CISPR bandwidths
• MILPk − Peak detector with MIL bandwidths
If the detector has been manually selected, a # appears next to it.
TIP RMS Detection
To measure the average power (RMS voltage) in each display point, set
Detector to Average, and verify that Avg/VBW Type is set to Pwr Avg (RMS).
Key Path: Det/Demod
State Saved: Saved in Instrument State
Factory Preset: Normal, Auto Coupled
Remote Command:
[:SENSe]:DETector[:FUNCtion] NORMal|AVERage|POSitive|SAMPle|NEGative|QPEak
|EAVerage|EPOSitive|MPOSitiv|RMS
[:SENSe]:DETector[:FUNCtion]?
The query returns a name that corresponds to the detector mode as shown by the following
terms:
NORMal Normal
AVERage Average
POSitive Peak
SAMPle Sample
NEGative Negative peak
QPEak Quasi Peak
EAVerage EMI Average
EPOSitive EMI Peak
MPOSitive MIL Peak
RMS RMS (alias)
Remote Command Notes:
The query returns a name that corresponds to the detector mode. The
RMS selection is an alias which selects the Average detector and Power
Averaging. Therefore, if RMS has been selected, the query will return the
AVER string.
Example: DET POS</Description>
            </Property>
            <Property>
               <Name>FREF</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1000000.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Not avaialable on the 4407</Description>
            </Property>
            <Property>
               <Name>FREFMODE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>Internal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>not available on the 4407</Description>
            </Property>
            <Property>
               <Name>HostID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:HID?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>IntPreamp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:GAIN</ConfigureCommand>
                     <QueryCommand>:POW:GAIN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the status of the internal pre-amp.

2.1.10 Int Preamp
Turns the internal preamp on and off. The preamp functions over a
frequency range of 100 kHz to 3 GHz (ex. for 1DS). When the preamp is on, an automatic adjustment
compensates for the gain of the preamp so that displayed amplitude readings still
accurately reflect the value at the analyzer input connector. The preamp is switched off for
frequencies above the amplifier, and the correction is not applied, even though the PA annotation
remains on screen. For signal frequencies below 100 kHz, the preamp is not automatically
switched out, but signal amplitude roll-off occurs even in the “DC” setting of the RF
Coupling control.
The gain of the preamp is nominally 30 dB (PSA).
Key Path: AMPLITUDE / Y Scale
Dependencies/
Couplings: Reference level, Attenuation
State Saved: Saved in Instrument State
Factory Preset: Off
Remote Command:
[:SENSe]:POWer[:RF]:GAIN[:STATe] OFF|ON|0|1
[:SENSe]:POWer[:RF]:GAIN[:STATe]?
Example: POW:GAIN 1
POW:GAIN?</Description>
            </Property>
            <Property>
               <Name>IPandHostName</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>no LAN available</Description>
            </Property>
            <Property>
               <Name>LLO</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Not available on 4407B</Description>
            </Property>
            <Property>
               <Name>LOPhNoiseOpt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>LOPhNoiseOptAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>MeasMethod</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>MeasMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INST:SEL</ConfigureCommand>
                     <QueryCommand>:INST:SEL?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Spectrum Analysis" Value="SA"/>
                     <Enum Name="cdmaOne" Value="CDMA"/>
                     <Enum Name="NADC" Value="NADC"/>
                     <Enum Name="PDC" Value="PDC"/>
                     <Enum Name="W-CDMA" Value="WCDMA"/>
                     <Enum Name="cdma2000" Value="CDMA2K"/>
                     <Enum Name="GSM_EDGE" Value="EDGEGSM"/>
                     <Enum Name="Phase Noise" Value="PNOISE"/>
                     <Enum Name="CDMA_1xEVDO" Value="CDMA1XEV"/>
                     <Enum Name="WLAN" Value="WLAN"/>
                     <Enum Name="Noise Figure" Value="NFIGURE"/>
                     <Enum Name="VSA_Link" Value="LINK"/>
                     <Enum Name="Measuring Reciever" Value="MRECEIVE"/>
                     <Enum Name="Digital Demod" Value="DMODULATION"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Spectrum Analysis</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Select the measurement mode by its mode number. The actual available choices depend
upon which applications are installed in your instrument.
Dependencies/
Couplings: Other modes, besides Spectrum Analysis, must be installed/licensed in
your instrument before they will appear in the Mode menu. Some modes
also require the presence of specific hardware.
SCPI Status Bits/
OPC Dependencies: If you are using the status bits and the analyzer mode is changed, the
status bits should be read, and any errors resolved, prior to switching
modes. Error conditions that exist prior to switching modes cannot be
detected using the condition registers after the mode change. This is true
unless they recur after the mode change, although transitions of these
conditions can be detected using the event registers.
Changing modes resets all SCPI status registers and mask registers to
their power-on defaults. Hence, any event or condition register masks
must be re-established after a mode change. Also note that the power up
status bit is set by any mode change, since that is the default state after
power up.
Factory Preset: 1 (Spectrum Analysis)
If Preset Type Mode is selected, then the analyzer settings are preset but it
stays in that selected mode.

1 = SA (PSA/ESA)
3 = GSM (GSM on E4406A, and GSM or GSM w/EDGE on ESA)
4 = CDMA (cdmaOne) (E4406/ESA/PSA)
5 = NADC (E4406/PSA)
6 = PDC (E4406/PSA)
8 = BASIC (E4406/PSA)
9 = WCDMA (3GPP W-CDMA with HSDPA/HSUPA) (E4406/PSA)
10 = CDMA2K (cdma2000 with 1xEV-DV) (E4406/PSA)
13 = EDGEGSM (E4406/PSA)
14 = PNOISE (phase noise) (ESA/PSA)
15 = CMDA1XEV (1xEV-D0) (E4406/PSA)
18 = WLAN (PSA)
211 = TDSCDMA (PSA)
219 = NOISEFIGURE (ESA/PSA)
233 = MRECEIVE (PSA)
241 = DMODULATION (PSA)</Description>
            </Property>
            <Property>
               <Name>MeasType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CONF</ConfigureCommand>
                     <QueryCommand>CONF?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Spectrum Analyzer" Value="SAN"/>
                     <Enum Name="Monitor Spectrum" Value="MON"/>
                     <Enum Name="Spot Freq Meas" Value="SFR"/>
                     <Enum Name="Log Plot Meas" Value="LPL"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Spectrum</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>queries or sets the measuremnt type must be in either basic or phase noise modes.</Description>
            </Property>
            <Property>
               <Name>MeasView</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>NumOptions</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 30;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>OneDBcompPt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
CF = str2double(query(interface, ':FREQ:CENT?'));
if CF &gt; 50e7 &amp;&amp; CF &lt;= 6.7e9
  propertyValue = 0;
elseif CF &gt; 6.7e9 &amp;&amp; CF &lt;= 13.2e9
  propertyValue = -3;
elseif CF &gt; 13.2e9 &amp;&amp; CF &lt;= 26.5e9
  propertyValue = -5;
end
 </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>OperationComplete</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>*OPC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Operation Complete
*OPC
*OPC?
The *OPC command sets bit 0 in the standard event status register to
“1” when pending operations have finished. It does not hold off
subsequent operations.
The *OPC? query stops new commands from being processed until the
current processing is complete. Then it returns a “1”, and the program
continues. This query can be used to synchronize events of other
instruments on the external bus.
The instrument does not wait for completion of all processes for these
commands. The processes that are monitored are identified in the
STATus:OPERation resgister. These include:
For example, if you want to verify the completion of both calibration
and waiting for trigger set :STAT:OPER:ENAB 33 and monitor any
changes.
Key Type: There is no equivalent front-panel key.

PSA Process    STATus:OPER     Byte Value
               Register Bit

Calibrating          0                1
Sweeping             3                8
MEASuring            4                16
(not in all modes)
Waiting for trigger  5                32</Description>
            </Property>
            <Property>
               <Name>qCALSTATUS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>STAT:QUES:CAL:COND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>queries the state of the cal align status to see if one is needed.</Description>
            </Property>
            <Property>
               <Name>qMODECAT</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
PossibleModes = {'SA', 'BASIC', 'CDMA', 'CDMA1XEV', 'CDMA2K', 'EDGEGSM', 'LINK',...
  'NADC', 'NFIGURE', 'PDC', 'PNOISE', 'TDSCDMA', 'WCDMA', 'Cable Fault Location',...
  'MAN'};
AvailableModes = query(interface, 'INST:CAT?');
propertyValue = [];
for ii = 1:length(PossibleModes)
  if ~isempty(findstr(AvailableModes, PossibleModes{ii}))
    propertyValue = [propertyValue ii];
  end
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>returns an integer array indicating what modes are available on the SA in use.
1 = Spectrum Analysis
2 = Basic
3 = CDMAOne
4 = CDMA1xEV-DO
5 = CDMA2000
6 = EDGE with GSM 
7 = 89600 VSA Link software
8 = NADC
9 = Noise Figure
10 = PDC
11 = Phase Noise
12 = TD-SCDMA
13 = W-CDMA for 3GPP
</Description>
            </Property>
            <Property>
               <Name>qONTIME</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:PON:ETIM?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>queries how long the analyzer has been on.</Description>
            </Property>
            <Property>
               <Name>qPOWERONTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:PON:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qPRESETTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
temp = query(interface, 'SYST:PRES:TYPE?');
if strncmpi(temp, 'MODE', 3)
  propertyValue = 'Mode';
elseif strncmpi(temp, 'FACT', 3)
  propertyValue = 'Factory';
elseif strncmpi(temp, 'USER', 3)
  propertyValue = 'User';
else
  % Some sort of Visa Error
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qSCPIVERSION</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:VERS?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qSTATOPERREG</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>STAT:OPER:COND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qUNCAL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
temp = str2double(query(interface, 'STAT:QUES:INT:UNC:COND?'));
if temp &gt; 0
  propertyValue = 1;
else
  propertyValue = 0;
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>RBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND</ConfigureCommand>
                     <QueryCommand>:BAND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8000000.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth

2.3.1 Res BW
Enables you to select the 3.01 dB resolution bandwidth (RBW) of the analyzer in 10% steps
from 1 Hz to 3 MHz, plus bandwidths of 4, 5, 6, or 8 MHz.
If an unavailable bandwidth is entered with the numeric keypad, the closest available
bandwidth is selected.
Sweep time is coupled to RBW. As the RBW changes, the sweep time (if set to Auto) is
changed to maintain amplitude calibration.
Video bandwidth (VBW) is coupled to RBW. As the resolution bandwidth changes, the
video bandwidth (if set to Auto) changes to maintain the ratio set by VBW/RBW.
When Res BW is set to Auto, resolution bandwidth is autocoupled to span, except when
using the CISPR and MIL detectors (Quasi Peak, EMI Average EMI Peak and MIL Peak).
For these detectors, Auto RBW coupling is to the center frequency. The ratio of span to
RBW is set by Span/RBW (described on page 82). The factory default for this ratio is
approximately 106:1 when auto coupled. When Res BW is set to Man, bandwidths are
entered by the user, and these bandwidths are used regardless of other analyzer settings.
NOTE In zero span, the auto/manual function of this key is not applicable. When Res
BW (Auto) is selected in non-zero span, any changes to Res BW while in zero
span will revert to the Auto value when you return to non-zero span. When
Res BW (Man) is selected in non-zero span, any changes to Res BW while in
zero span will be maintained when you return to non-zero span.
NOTE When the Quasi Peak or one of the EMI detectors are selected, the resolution
bandwidths available are restricted to the set defined in Table 2-2, “CISPR
Bandwidths with RBW Set to Auto,” on page 91. When the MIL Peak detector
is selected, the resolution bandwidths available are restricted to the set
defined in Table 2-4, “MIL Specifications for Bandwidth vs. Frequency with
RBW Set to Auto,” on page 94.
A # mark appears next to Res BW on the bottom of the analyzer display when it is not
coupled. To couple the resolution bandwidth, press Res BW (Auto) or Auto All .
74 Chapter 2
Instrument Functions: A - L
BW/Avg
Instrument Functions: A - L
NOTE For applications that require 6 dB resolution bandwidths, it is possible to use
an equivalent 3 dB resolution bandwidth. Because the analyzer has Guassian
RBW, the equivalent 6 dB bandwidth of any RBW filter can be determined
using the following formula: 6 dB RBW = 3 dB RBW x 1.414. For example, if a
6 dB RBW of 100 kHz is required, the equivalent 3 dB RBW Filter would be
100 kHz/1.414 = 70.7 kHz. The closest RBW filter for the analyzer that would
be used is 68 kHz.
Key Path: BW/Avg
Saved State: Saved in Instrument State
Factory Preset: Auto (3 MHz)
Range: 1 Hz to 8 MHz
Remote Command:
[:SENSe]:BANDwidth|BWIDth[:RESolution] &lt;freq&gt;
[:SENSe]:BANDwidth|BWIDth[:RESolution]?
[:SENSe]:BANDwidth|BWIDth[:RESolution]:AUTO OFF|ON|0|1
[:SENSe]:BANDwidth|BWIDth[:RESolution]:AUTO?
Example: BAND 1 kHz
BAND?
BWID:AUTO On
BWID:AUTO?</Description>
            </Property>
            <Property>
               <Name>RefLevel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:RLEV</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:RLEV?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>2.1.1 Ref Level
Enables you to adjust the absolute amplitude represented by the top graticule line on the
display (the reference level). Ref in the upper left corner of the display, indicates the
current value. The Amplitude, Y Axis Units setting determines the Reference Level units. To
change the reference level, use the front-panel step keys, knob, or numeric keypad.
Key Path: AMPLITUDE / Y Scale
Dependencies/
Couplings: If you reduce the Attenuation setting, the analyzer may have to lower the
Reference Level to maintain the proper level at the top of the screen. If you
then increase Attenuation, the Reference Level does not increase to its
previous value.
When the input attenuator is auto-coupled, Attenuation (Auto), its setting
may be affected by changes in the reference level setting. See
“Attenuation” on page 36.
Reference level is affected by: Attenuation, Preamp, Ext Amp Gain,
Reference level offset, Max Mixer Level, Y-Axis Units.
State Saved: Saved in Instrument State
Factory Preset: 0 dBm
Range: Determined by the settings of the input attenuator, reference level offset,
external amplitude gain, and whether the preamp (Option 1DS) is on or
off.
Examples:
−170 dBm to 30 dBm with zero reference level offset
−180 dBm to 20 dBm with 10 dB ext amp gain
−160 dBm to 40 dBm with 10 dB reference level offset
−170 dBm to 0 dBm with preamp on (Option 1DS)
36 Chapter 2
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
Remote Command:
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:RLEVel &lt;ampl&gt;
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:RLEVel?
Example: DISP:WIND:TRAC:Y:RLEV 20 dbm
Sets the reference level to 20 dBm, which displays in the current Y-Axis
Units. For example, if the Y-Axis Units are dBμV, then 127 dBμV will be
displayed.</Description>
            </Property>
            <Property>
               <Name>RFCPL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INP:COUP</ConfigureCommand>
                     <QueryCommand>:INP:COUP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ac" Value="AC"/>
                     <Enum Name="dc" Value="DC"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ac</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or gets the RF input coupling.


2.8.2 RF Coupling
Specifies alternating current (AC) or direct current (DC) coupling at the analyzer RF input
port. Selecting AC coupling switches in a blocking capacitor that blocks any DC voltage
present at the analyzer input. This decreases the input frequency range of the analyzer,
but prevents damage to the input circuitry of the analyzer if there is a DC voltage present
at the RF input.
In AC coupling mode, signals less than 20 MHz are not calibrated. You must switch to DC
coupling to see calibrated frequencies of less than 20 MHz. Note that the message
DC Coupled will be displayed on the analyzer when DC is selected.
Some amplitude specifications apply only when coupling is set to DC. Refer to the
appropriate amplitude specifications and characteristics for your analyzer.
CAUTION When operating in DC coupled mode, ensure protection of the input mixer by
limiting the input level to within 200 mV of 0 Vdc. In AC or DC coupling, limit
the input RF power to +30 dBm..
Key Path: Input/Output
Dependencies/
Couplings: In external mixing mode, input port and RF coupling selection are not
available. Not available on 40 GHz or 50 GHz analyzers.
State Saved: Saved in Instrument State
Factory Preset: AC
Remote Command:
:INPut:COUPling AC|DC
:INPut:COUPling?
Example: INP:COUP DC</Description>
            </Property>
            <Property>
               <Name>SAAttnAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:ATT:AUTO</ConfigureCommand>
                     <QueryCommand>:POW:ATT:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the attenuation auto mode
This will not work in all modes

[:SENSe]:POWer[:RF]:ATTenuation:AUTO OFF|ON|0|1
[:SENSe]:POWer[:RF]:ATTenuation:AUTO?
Remote Command Notes: . The Reference Level setting may be affected when the
Attenuation is changed. See Ref Level.
Example:. POW:ATT 30
POW:ATT?
POW:ATT:AUTO ON
POW:ATT:AUTO?</Description>
            </Property>
            <Property>
               <Name>SABlank</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:ENAB</ConfigureCommand>
                     <QueryCommand>:DISP:ENAB?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="On" Value="ON"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Turns the display on/off. If enable is set to off, the display will appear to blank. This can
make the measurement run faster since the instrument does not have to update the
display after every data acquisition. There is often no need to update the display
information when using remote operation.
• Sending SYSTem:PRESet or *TST commands will turn it on. *RST will not.
Key Path: None, no front-panel control.
State Saved: Not saved in instrument state.</Description>
            </Property>
            <Property>
               <Name>SADate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

interface = get(obj, 'Interface');

date = query(interface, ':SYST:DATE?');

month_tab = {'Jan','Feb','Mar','Apr','May','Jun',...
             'Jul','Aug','Sep','Oct','Nov','Dec'}
             
coma_idx = find(date == ',');

year = date(coma_idx(1)-4:coma_idx(1)-1);
month = date(coma_idx(1)+1:coma_idx(2)-1);
month = month_tab{str2double(month)}
day = date(coma_idx(2)+1:end-1);
propertyValue = [month ' ' day ', ' year];</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>THIS COMMAND HAS NOT BEEN TESTED!

Gets the instrument date

4.9.3.5 Set Date
Allows you to set the date of the real-time clock. Enter the date in the YYYYMMDD format.
Key Path: System, Time/Date
State Saved: Survives Preset and power cycle, but not saved in Instrument State nor
restored by System, Restore Sys Defaults.
SCPI Status Bits/
OPC Dependencies: None
Factory
Default: Not affected by “Restore Sys Defaults.”
Terminators: Unitless
Range: Year (YYYY): 1970 to 2029
Month (MM):01 to 12
Day: 01 to 30 or 31 (depending on the month)
Remote Command:
:SYSTem:DATE &lt;year&gt;,&lt;month&gt;,&lt;day&gt;
:SYSTem:DATE?
Example: SYST:DATE 2000,12,24 Sets the date to December 24, 2000</Description>
            </Property>
            <Property>
               <Name>SADetAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DET:AUTO</ConfigureCommand>
                     <QueryCommand>:DET:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the detector type auto mode.

See the SpecDet property for more info.</Description>
            </Property>
            <Property>
               <Name>SAPeakExc</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:CALC:MARK:PEAK:EXC</ConfigureCommand>
                     <QueryCommand>:CALC:MARK:PEAK:EXC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the peak excursion value

4.1.8.1 Peak Excursn
Sets the minimum amplitude variation of signals that the marker can identify as a
separate peak. For example, if a peak excursion value of 10 dB is selected, the marker Next
Peak function moves only to peaks that rise more than 10 dB above the Peak Threshold and
then fall back down by at least the Peak Excursn. This criteria applies to all traces. This
function applies to Next Peak, Next Peak Left, and Next Peak Right. If Peak Search is set to
Param, it also applies to Peak Search.
Key Path: Peak Search, Search Param
Dependencies/
Couplings: This function is not available when Y-Axis is set to Frequency instead of
Amplitude.
State Saved: Saved in instrument state.
Factory Preset: 6.0 dB
Factory
Default: 6.0 dB
Terminators: dB
Default Terminator: dB
Resolution/
Rounding/
Truncation: 0.01 dB
Knob Increment: 1 dB
Step Key
Increment: 1 dB
Range: 0.0 dB to 100 dB
Remote Command:
:CALCulate:MARKer[1]|2|3|4:PEAK:EXCursion &lt;rel_amplitude&gt;
:CALCulate:MARKer[1]|2|3|4:PEAK:EXCursion?
Remote Command Notes: CALC:MARK:PEAK:SEAR:MODE must be set to PARameter
ig you want Peak Search to take advantage of the threshold excursion.
Example: :CALC:MARK:PEAK:EXC 30 DB sets the minimum peak excursion
requirement to 30 dB.
See the full example for the CALC:MARK:PEAK:SEAR:MODE command
below.</Description>
            </Property>
            <Property>
               <Name>SAPeakThresh</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:CALC:MARK:PEAK:THR</ConfigureCommand>
                     <QueryCommand>:CALC:MARK:PEAK:THR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the peak threshold value

4.1.8.2 Pk Threshold
Specifies the minimum signal level for the analyzer internal peak identification routine to
recognize as a peak. To be considered a peak, a signal must rise above the Peak Threshold
value by at least the value specified in Peak Excursn, then fall back down by at least the
Peak Excursn. This applies to all traces and all windows. Press ESC or select another active
function to hide the threshold line. Applies to Next Peak, Next Peak Left, and Next Peak Right.
If Peak Search is set to Param, it also applies to Peak Search.
Key Path: Peak Search, Search Param
Dependencies/
Couplings: This function is not available when Y-Axis is set to Frequency instead of
Amplitude.
State Saved: Saved in instrument state.
Factory Preset: –90 dBm
Terminators: dBmV, dBμV, dBμΑ, V, W, A
Default Terminator: dBm
Resolution/
Rounding/
Truncation: .001 dBm
Knob Increment: amp scale = LOG: 1 % of dB/div or 0.01 (the larger of the two)
amp scale = LIN: 0.1 dBm
Step Key
Increment: amp scale = LOG: dB/div
amp scale = LIN:
Range: From the current reference level to the bottom of the display range
Remote Command:
:CALCulate:MARKer[1]|2|3|4:PEAK:THReshold &lt;ampl&gt;
:CALCulate:MARKer[1]|2|3|4:PEAK:THReshold?
Remote Command Notes: CALC:MARK:PEAK:SEAR:MODE must be set to PARameter if
you want peak search to take advantage of the threshold excursion.
Example: :CALC:MARK:PEAK:THR -60 dBm sets the threshold to -60 dBm.
See the full example for the CALC:MARK:PEAK:SEAR:MODE command
below.</Description>
            </Property>
            <Property>
               <Name>SAPresetType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SYST:PRES:TYPE</ConfigureCommand>
                     <QueryCommand>:SYST:PRES:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="factory" Value="FACT"/>
                     <Enum Name="user" Value="USER"/>
                     <Enum Name="mode" Value="MODE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>mode</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the instrument preset mode.

4.9.2.2 Preset Type
Enables you to select what type of preset will be initiated when you press the green Preset
key or send the remote command, using SYST:PRES. Choose between Factory, Mode, or
User defined presets.
Key Path: System, Power On/Preset
State Saved: Survives Preset and power cycle, but is not saved in Instrument State.
SCPI Status Bits/
OPC Dependencies: None
Preset: Does not change the Preset Type.
Factory
Default: Mode
Remote Command:
:SYSTem:PRESet:TYPE FACTory|USER|MODE
:SYSTem:PRESet:TYPE?
Remote Command Notes: SYSTem:PRESet:USER:SAVE defines the user preset.
Example: SYST:PRES:TYPE FACT defines the type of preset as the factory preset.</Description>
            </Property>
            <Property>
               <Name>SARBWAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:AUTO</ConfigureCommand>
                     <QueryCommand>:BAND:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth auto mode

See SpecRBW for more details
</Description>
            </Property>
            <Property>
               <Name>SATime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

interface = get(obj, 'Interface');

time = query(interface, ':SYST:TIME?');

coma_idx = find(time == ',');

hour = time(1:coma_idx(1)-1);
minute = time(coma_idx(1)+1:coma_idx(2)-1);
sec = time(coma_idx(2)+1:end-1);

propertyValue = [hour 'h ' minute 'm ' sec 's'];</GetMCode>
                  <SetMCode>tyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>SATitle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:ANN:TITL:DATA</ConfigureCommand>
                     <QueryCommand>:DISP:ANN:TITL:DATA?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>No title</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or Queries the display title

2.5.5 Title
Displays menu keys that enable you to change or clear a title on your display.
Key Path: Display
2.5.5.1 Change Title
Allows you to write a title across the top of the display. Press Change Title to access the
Alpha Editor Menus that contain available characters and symbols. You may also use the
numeric keypad to enter numbers. Press Enter or Return to complete the entry. Press ESC to
cancel the entry and preserve your existing title.
The display title will remain until you press Change Title again, or you recall a trace or
state, or a
Factory Preset is performed. A title can also be cleared by pressing Title, Clear Title.
Pressing this key cancels any active function.
Key Path: Display, Title
State Saved: Saved in instrument state.
Remote Command:
:DISPlay:ANNotation:TITLe:DATA &lt;string&gt;
:DISPlay:ANNotation:TITLe:DATA?
Example: DISP:ANN:TITL:DATA “This Is My Title”</Description>
            </Property>
            <Property>
               <Name>SAVBWAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:VID:AUTO</ConfigureCommand>
                     <QueryCommand>:BAND:VID:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth auto mode

See Spec VBW for more info</Description>
            </Property>
            <Property>
               <Name>ScalePerDiv</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:PDIV</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:PDIV?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="20.0" Min="0.1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the logarithmic units per vertical graticule division on the display.

2.1.3 Scale/Div
Sets the units per vertical graticule division on the display. This function is only available
when Scale Type (Log) is selected and the vertical scale is power, or Demod View is on and
the vertical scale is hertz. When Scale Type (Lin) is selected, Scale/Div is grayed out.
Key Path: AMPLITUDE / Y Scale
State Saved: Saved in Instrument State
Factory Preset: 10 dB, in logarithmic scale type
Fundamental
Units: dB; kHz
Terminators: dB; Hz, kHz, MHz, GHz
Default
Terminator: dB; kHz
Range: 0.1 dB to 20 dB
1 kHz to 240 kHz (When Demod View (On) is selected.)
Remote Command:
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:PDIVision &lt;power&gt;
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:PDIVision?
Example: DISP:WIND:TRAC:Y:PDIV 5 DB</Description>
            </Property>
            <Property>
               <Name>ScaleType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:SPAC</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:SPAC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="lin" Value="LIN"/>
                     <Enum Name="log" Value="LOG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Log</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical scale type for the display

2.1.4 Scale Type
Allows you to choose a linear or logarithmic vertical scale for the display and for remote
data readout.
The scale type for display and remote data readout may be differenet from the scale used
for averaging processes. For information on the scale used for averaging process,
“Avg/VBW Type” on page 79.
When Scale Type (Log) is selected, the vertical graticule divisions are scaled in logarithmic
units. The top line of the graticule is the Reference Level and use the scaling per division,
Scale/Div to assign values to the other locations on the graticule.
When Scale Type (Lin) is selected, the vertical graticule divisions are linearly scaled with
the reference level value at the top of the display and zero volts at the bottom. Each
vertical division of the graticule represents one-tenth of the Reference Level.
The Y Axis Units used for each type of display are set by pressing Y Axis Units. The
analyzer remembers the settings for both Log and Lin.
Key Path: AMPLITUDE / Y Scale
State Saved: Saved in Instrument State
Factory Preset: Log
Remote Command:
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:SPACing LINear|LOGarithmic
:DISPlay:WINDow[1]:TRACe:Y:[SCALe]:SPACing?
Example: DISP:WIND:TRAC:Y:SPAC LOG
DISP:WIND:TRAC:Y:SPAC?</Description>
            </Property>
            <Property>
               <Name>Span</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:SPAN</ConfigureCommand>
                     <QueryCommand>:FREQ:SPAN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the frequency span

Changes the displayed frequency range symmetrically about the center frequency. Setting
the span to 0 Hz puts the analyzer into zero span.
Key Path: SPAN X Scale
Dependencies/
Couplings: Span is coupled to center frequency. The maximum span may be limited by
the center frequency setting.
State Saved: Saved in Instrument State
Factory Preset:
Fundamental Units: Hz
Terminators: GHz, MHz, kHz, Hz
Default Terminator: Hz
Range:
Model Span
E4440A 26.49 GHz
E4443A 6.69 GHz
E4445A 13.19 GHz
E4446A 43.99 GHz
E4447A 42.98 GHz
E4448A 49.99 GHz
Model 0 Hz, Span Range
E4440A 10 Hz to 26.50 GHz
E4443A 10 Hz to 6.70 GHz
E4445A 10 Hz to 13.20 GHz
E4446A 10 Hz to 44.00 GHz
E4447A 10 Hz to 42.98 GHz
E4448A 10 Hz to 50.00 GHz
236 Chapter 4
Instrument Functions: P - Z
SPAN / X Scale
Instrument Functions: P - Z
Remote Command:
[:SENSe]:FREQuency:SPAN &lt;freq&gt;
[:SENSe]:FREQuency:SPAN?
Example: FREQ:SPAN 2 GHZ</Description>
            </Property>
            <Property>
               <Name>SpotOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>StartFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:STAR</ConfigureCommand>
                     <QueryCommand>:FREQ:STAR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-1.0E8</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the start frequency

2.7.2 Start Freq
Sets the frequency at the left side of the graticule and sets the frequency entry mode to
Start/Stop. When the Start/Stop Frequency entry mode is activate, the start and stop
frequency values are displayed below the graticule in place of center frequency and span.
The left and right sides of the graticule correspond to the start and stop frequencies.
When Start Freq reaches the upper frequency limit, the stop frequency is set to the highest
available frequency and the start frequency is changed to be less then the stop frequency
by the minimum span (10 Hz). Center Freq will be updated to the stop frequency minus
one-half of the span, or to the stop frequency minus 5 Hz, and Res BW and VBW will be set
to 1 Hz.
Key Path: FREQUENCY
State Saved: Saved in Instrument State
Factory Preset: 10 MHz
Range:
Remote Command:
[:SENSe]:FREQuency:STARt &lt;freq&gt;
[:SENSe]:FREQuency:STARt?
Example: FREQ:STAR 200 MHz
FREQ:STAR?</Description>
            </Property>
            <Property>
               <Name>StopFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:STOP</ConfigureCommand>
                     <QueryCommand>:FREQ:STOP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-1.0E8</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the stop frequency

2.7.3 Stop Freq
Sets the frequency at the right side of the graticule and sets the frequency entry mode to
Start/Stop. When the Start/Stop Frequency entry mode is activate, the start and stop
frequency values are displayed below the graticule in place of center frequency and span.
The left and right sides of the graticule correspond to the start and stop frequencies.
Key Path: FREQUENCY
State Saved: Saved in Instrument State
Factory Preset:
Range:
Remote Command:
[:SENSe]:FREQuency:STOP &lt;frequency&gt;
[:SENSe]:FREQuency:STOP?
Example: FREQ:STOP 1600
FREQ:STOP?</Description>
            </Property>
            <Property>
               <Name>SweepMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INIT:CONT</ConfigureCommand>
                     <QueryCommand>:INIT:CONT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Continuous" Value="ON"/>
                     <Enum Name="Single" Value="OFF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Continuous</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>SweepPoints</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SWE:POIN</ConfigureCommand>
                     <QueryCommand>:SWE:POIN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="2.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1001</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Queries the number of trace points

4.8.6 Points
Sets the number of points per sweep, from 101 to 8192 in non-zero span and 2 to 8192 in
zero span. Resolution of setting the sweep time will depend on the number of points
selected. If Factory Preset is selected, or the analyzer power is cycled, the number of points
per sweep will default to 601. The current value of points is displayed parenthetically, next
to the sweep time in the lower-right corner of the display (refer to “Display Annotation” in
your Getting Started guide).
Changing the number of points has several effects on the analyzer. Since markers are read
at the point location, the marker reading may change. All trace data for the active trace is
cleared. If sweep is set to Cont (press Sweep, Sweep), a new sweep begins immediately. If
average is set to On (press BW/Avg, Average), the averaging starts over with a count of 0. If
limit lines are set to On (press Display, Limits, Modify, Limit 1 or 2), the limit lines are
updated.
NOTE By selecting a number of sweep points greater than 601, you are optimizing
frequency resolution and accuracy while accepting a reduced measurement
speed. In addition to sweep points, the span, resolution bandwidth, video
bandwidth, average detection and center frequency will also affect
measurement speed.
This function is coupled with the span setting. Increasing the span can
change the number of sweep points. In order to maintain accurate
measurements, the number of sweep points is increased if required to keep
the width of each sweep point at most 150 MHz.
When zone span is set to On (press Span, Zone. Zone), each window has its
own value for points.
Key Path: Sweep
State Saved: Saved in instrument state
Chapter 4 249
Instrument Functions: P - Z
SWEEP
Instrument Functions: P - Z
Factory Preset: 601
Range: 101 to 8192, 2 to 8192 in zero span
Remote Command:
[:SENSe]:SWEep:POINts &lt;number of points&gt;
[:SENSe]:SWEep:POINts?
Example: SWE:POIN 501
SWE:POIN?</Description>
            </Property>
            <Property>
               <Name>SweepsToAvg</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:AVER:COUN</ConfigureCommand>
                     <QueryCommand>:AVER:COUN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the average count value.

[:SENSe]:AVERage:COUNt &lt;integer&gt;
[:SENSe]:AVERage:COUNt?
[:SENSe]:AVERage:CLEar
Remote Command Notes: For valid average data, you must re-start the trace at the
beginning of a sweep. To do this remotely, first abort (:ABORT) the sweep
and then initiate a single sweep (:INIT:CONT OFF).
Example: AVER ON
AVER:COUN 100
AVER:CLE clears the current average and restarts the averaging process.</Description>
            </Property>
            <Property>
               <Name>SweepTime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SWE:TIME</ConfigureCommand>
                     <QueryCommand>:SWE:TIME?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="6000.0" Min="1.0E-6"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0E-6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Queries the trace sweep time

4.8.1 Sweep Time
Selects the length of time in which the spectrum analyzer sweeps the displayed frequency
span. In swept spans, the sweep time varies from 1 millisecond to 2000 seconds plus time
for setup which is not calculated as part of the sweep time. Reducing the sweep time
increases the rate of sweeps. In zero span, the sweep time may be set from 1 μs to 6000 s.
In FFT spans, the sweep time is not controlled by the user, but is an estimate of the time
required to make FFT measurements. Sweep time is coupled to RBW and VBW, so
changing those parameters may change the sweep time. When the analyzer has been set to
FFT, Sweep Time, and Auto Sweep Time are disabled (grayed out).
You may select a sweep time less than the auto-coupled value; however this may generate
measurement errors. If this happens, the error message: Meas Uncal will appear in the
upper right corner of the display.
NOTE In zero span or FFT sweeps, the auto/manual function of this key is not
applicable. When Sweep Time (Auto) is selected in non-zero span, any changes
to Sweep Time while in zero span will revert to the Auto value when you
return to non-zero span. When Sweep Time (Man) is selected in non-zero span,
any changes to Sweep Time while in zero span will be maintained when you
return to non-zero span (within the available sweep time range). When
entering zero span from a non-zero span, the sweep time does not change.
Key Path: Sweep
Annunciation/
Annotation: The sweep is displayed in the lower-right corner of the screen. Also, the
points displayed parenthetically.
State Saved: Saved in Instrument State
Factory Preset: Auto
Model Sweep Time
E4440A 66.24 ms
E4443A 11.16 ms
E4445A 22.00 ms
E4446A 110.00 ms
E4447A 107.50 ms
E4448A 125.00 ms
240 Chapter 4
Instrument Functions: P - Z
SWEEP
Instrument Functions: P - Z
Default Terminator: seconds
Range: in zero span: 1 μs to 6000s
in swept spans: 1 ms to 2000s
Remote Command:
[:SENSe]:SWEep:TIME &lt;time&gt;
[:SENSe]:SWEep:TIME?
[:SENSe]:SWEep:TIME:AUTO OFF|ON|0|1
[:SENSe]:SWEep:TIME:AUTO?
Example: SWE:TIME 500 ms
SWE:TIME:AUTO OFF</Description>
            </Property>
            <Property>
               <Name>TrackPower</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SOUR:POW</ConfigureCommand>
                     <QueryCommand>SOUR:POW?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="3.0" Min="-66.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the power level of the tracking generator output</Description>
            </Property>
            <Property>
               <Name>TrackPowerMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SOUR:POW:MODE</ConfigureCommand>
                     <QueryCommand>:SOUR:POW:MODE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Fixed" Value="FIX"/>
                     <Enum Name="Swept" Value="SWE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Fixed</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the mode of the tracking generator</Description>
            </Property>
            <Property>
               <Name>TrackPowerState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:OUTP</ConfigureCommand>
                     <QueryCommand>:OUTP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>turns tracking generator power on or off</Description>
            </Property>
            <Property>
               <Name>TrackPowerSweepSpan</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SOUR:POW:SPAN</ConfigureCommand>
                     <QueryCommand>:SOUR:POW:SPAN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="20.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the tracking generator sweep range. use TrackPower to set center power level</Description>
            </Property>
            <Property>
               <Name>TrigLevel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>TrigSlope</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:EXT:SLOP</ConfigureCommand>
                     <QueryCommand>:TRIG:EXT:SLOP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Negative" Value="NEG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>POS</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the external trigger slope.</Description>
            </Property>
            <Property>
               <Name>TrigSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:SOUR</ConfigureCommand>
                     <QueryCommand>:TRIG:SOUR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="freerun" Value="IMM"/>
                     <Enum Name="video" Value="VID"/>
                     <Enum Name="line" Value="LINE"/>
                     <Enum Name="external" Value="EXT1"/>
                     <Enum Name="TV" Value="TV"/>
                     <Enum Name="RFburst" Value="RFB"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>freerun</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger source

4.11 Trig
Displays menu keys that enable you to select the trigger mode of a sweep or measurement.
When in a trigger mode other than Free Run, the analyzer will begin a sweep only with the
proper trigger condition.
In FFT measurements, the trigger controls when the data is acquired for FFT conversion;
see “Making Gated FFT Measurements With Your PSA” on page 63.
Key Path: Front-panel key
State Saved: Saved in Instrument State
Factory Preset: Free Run
Remote Command:
:TRIGger[:SEQuence]:SOURce
IMMediate|VIDeo|LINE|EXTernal[1]|EXTernal2|RFBurst
:TRIGger[:SEQuence]:SOURce?
IMM = Free Run triggering
VID = Video–triggers on the video signal level
LINE = Line–triggers on the power line signal
Ext1 = External Front–enables you to trigger on an externally connected trigger source
Ext2 = External Rear–enables you to trigger on an externally connected trigger source
Remote Command Notes: Other trigger-related commands are found in the INITiate and
ABORt subsystems.
Example: TRIG:SOUR VID
300 Chapter 4
Instrument Functions: P - Z
Trig
Instrument Functions: P - Z
4.11.1 Free Run
Sets the trigger to start a new sweep/measurement as soon as the last one has ended
(continuous sweep mode) or immediately (single sweep mode).
Key Path: Trig
Dependencies/
Couplings: Trigger Slope and Delay adjustments are not available with Free Run
triggering.
Remote Command:
See “Trig” on page 299
Example: TRIG:SOUR IMM
4.11.2 Video
Activates the trigger condition that allows the next sweep to start if the detected RF
envelope voltage crosses a level set by the video trigger level. When Video is pressed, a line
appears on the display. The analyzer triggers when the input signal exceeds the trigger
level at the left edge of the display. You can change the trigger level using the step keys,
the knob, or the numeric keypad. The line remains as long as video trigger is the trigger
type.
Key Path: Trig
Dependencies/
Couplings: Trigger Delay adjustment is not available with Video triggering.
Video triggering is not available when the detector is Average. Marker
Functions that set the detector to average (such as Marker Noise or
Band/Intvl Power) are not available when the video trigger is on.
This function is not available when the Resolution Bandwidth is less than
1 kHz. If a Resolution Bandwidth less than 1 kHz is selected while in
Video Trigger mode, the Trigger mode changes to Free Run.
Factory Preset: –25 dBm
Range: Using logarithmic scale: from 10 display divisions below the reference
level, up to the reference level
Using linear scale: from 100 dB below the reference level, up to the
reference level
For more information, see “Scale Type” on page 38.
Chapter 4 301
Instrument Functions: P - Z
Trig
Instrument Functions: P - Z
Remote Command:
See “Trig” on page 299 for the command that sets trigger mode. The following commands
set/read the trigger level.
:TRIGger[:SEQuence]:VIDeo:LEVel &lt;ampl&gt;
:TRIGger[:SEQuence]:VIDeo:LEVel?
:TRIGger[:SEQuence]:VIDeo:LEVel:FREQuency &lt;freq&gt; sets the Video Trigger level
when in FM Demod, and Demod View is on
:TRIGger[:SEQuence]:VIDeo:LEVel:FREQuency?
Example: TRIG:SOUR VID selects video triggering.
4.11.3 Line
Sets the trigger to start a new sweep/measurement to be synchronized with the next cycle
of the line voltage.
Key Path: Trig
Couplings/
Dependencies: Line trigger is not available when operating from a dc power source.
Remote Command:
See “Trig” on page 299
Example: TRIG:SOUR LINE selects line triggering.
4.11.4 Ext Front (Ext Trig In)
Sets the trigger to start a new sweep/measurement whenever the external voltage
(connected to EXT TRIGGER INPUT on the front panel) passes through approximately 1.5
volts.
Key Path: Trig
State Saved: Saved in instrument state
Factory Preset: 1.5 V
Remote Command:
See “Trig” on page 299
Example: TRIG:SOUR EXT to select front panel external triggering.
302 Chapter 4
Instrument Functions: P - Z
Trig
Instrument Functions: P - Z
4.11.5 Ext Rear (Trigger In)
Sets the trigger to start a new sweep/measurement whenever the external voltage
(connected to TRIGGER IN on the rear panel) passes through approximately 1.5 volts.
Key Path: Trig
State Saved: Saved in instrument state
Factory Preset: 1.5 V
Remote Command:
See “Trig” on page 299
Example: TRIG:SOUR EXT2 to select rear panel external triggering.
4.11.6 RF Burst (Wideband)
Allows the analyzer to be triggered by an RF burst envelope signal.
Key Path: Trig
Remote Command:
See “Trig” on page 299
Example: TRIG:SOUR RFB</Description>
            </Property>
            <Property>
               <Name>VBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:VID</ConfigureCommand>
                     <QueryCommand>:BAND:VID?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="5.0E7" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the video bandwidth

2.3.2 Video BW
Enables you to change the analyzer post-detection filter from 1 Hz to 8 MHz in
approximately 10% steps. In addition, a wide-open video filter bandwidth (VBW) may be
chosen by selecting 50 MHz. Video BW (Auto) selects automatic coupling of the Video BW
filter to the resolution bandwidth filter using the VBW/RBW ratio set by the VBW/RBW key.
NOTE Sweep Time is coupled to Video Bandwidth (VBW). As the VBW is changed,
the sweep time (when set to Auto) is changed to maintain amplitude
calibration. This occurs because of common hardware between the two
circuits, even though the Video BW filter is not actually “in-circuit” when the
detector is set to Average. Because the purpose of the average detector and
the VBW filter are the same, either can be used to reduce the variance of the
result.
Although the VBW filter is not “in-circuit” when using the average detector,
the Video BW key can have an effect on (Auto) sweep time, and is not
disabled. In this case, reducing the VBW setting increases the sweep time,
which increases the averaging time, producing a lower-variance trace.
However, when the EMI Average detector is selected, the Video BW is
restricted to 1 Hz while the sweep time is set to Auto.
When using the average detector with either Sweep Time set to Man, or in zero
span, the VBW setting has no effect and is disabled (grayed out).
A “#” mark appears next to VBW on the bottom of the analyzer display when it is not
coupled. To couple the video bandwidth, press Video BW (Auto) (or press Auto All).
Key Path: BW/Avg
Saved State: Saved in Instrument State
Factory Preset: Auto (3 MHz)
Range: 1 Hz to 50 MHz
Remote Command:
[:SENSe]:BANDwidth|BWIDth:VIDeo &lt;freq&gt;
[:SENSe]:BANDwidth|BWIDth:VIDeo?
[:SENSe]:BANDwidth|BWIDth:VIDeo:AUTO OFF|ON|0|1
[:SENSe]:BANDwidth|BWIDth:VIDeo:AUTO?
Example: BAND:VID 1 kHz
BAND:VID?
BWID:VID:AUTO ON
BWID:VID:AUTO?</Description>
            </Property>
            <Property>
               <Name>VideoAvg</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:AVER</ConfigureCommand>
                     <QueryCommand>:AVER?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trace averaging mode.

2.3.4 Average
Initiates a digital averaging routine that averages the trace points in a number of
successive sweeps, resulting in trace “smoothing.” You can select the number of sweeps
(average number) with the numeric keypad (not the knob or step keys). Increasing the
average number further smooths the trace. To select the type of averaging used, press
BW/Avg, Avg/VBW Type.
Averaging restarts when any of the following occurs:
• a new average number is entered.
• any measurement related parameter (e.g., center frequency) is changed.
• Restart is pressed.
• Single Sweep is pressed.
In single sweep, the specified number of averages is taken, then the sweep stops. In
continuous sweep, the specified number of averages is taken, then the averaging
continues, with each new sweep averaged in with a weight of and the old
average reduced by multiplying it by .
To turn off averaging, press Average (Off).
Key Path: BW/Avg
Saved State: Saved in Instrument State
Factory Preset: Off, 100 averages
Range: Count: 1 to 8192
Remote Commands:
[:SENSe]:AVERage[:STATe] OFF|ON|0|1
[:SENSe]:AVERage[:STATe]?
[:SENSe]:AVERage:COUNt &lt;integer&gt;
[:SENSe]:AVERage:COUNt?
[:SENSe]:AVERage:CLEar
Remote Command Notes: For valid average data, you must re-start the trace at the
beginning of a sweep. To do this remotely, first abort (:ABORT) the sweep
and then initiate a single sweep (:INIT:CONT OFF).
Example: AVER ON
AVER:COUN 100
AVER:CLE clears the current average and restarts the averaging process.</Description>
            </Property>
            <Property>
               <Name>YUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:UNIT:POW</ConfigureCommand>
                     <QueryCommand>:UNIT:POW?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="dbm" Value="DBM"/>
                     <Enum Name="dbmV" Value="DBMV"/>
                     <Enum Name="dbuV" Value="DBUV"/>
                     <Enum Name="V" Value="V"/>
                     <Enum Name="W" Value="W"/>
                     <Enum Name="dbma" Value="DBMA"/>
                     <Enum Name="dbua" Value="DBUA"/>
                     <Enum Name="dbuvm" Value="DBUVM"/>
                     <Enum Name="dbuam" Value="DBUAM"/>
                     <Enum Name="dbpt" Value="DBPT"/>
                     <Enum Name="dbg" Value="DBG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>dbm</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the y axis units

2.1.8 Y Axis Units
Displays the menu keys that enable you to change the vertical (Y) axis amplitude units.
The analyzer retains the entered Y Axis Units separately for both Log and Lin amplitude
scale types. For example, if Scale Type has been set to Log, and you set Y Axis Units to dBm,
pressing Scale Type (Log) sets the Y Axis Units to dBm. If Scale Type has been set to Lin and
you set Y Axis Units to Volts, pressing Scale Type (Lin) sets the Y Axis Units to Volts. Pressing
Scale Type (Log) again sets the Y Axis units back to dBm.
This key is unavailable (grayed out) when the FM Demod View is on.
Y Axis Units, in conjunction with the Scale Type, affect how the data is read off the display,
markers, and over the remote interface. When using the remote interface no units are
returned, so you must know what the Y-Axis units are to interpret the results:
Key Path: AMPLITUDE / Y Scale
State Saved: Saved in Instrument State
Factory Preset: For Scale Type (Log) = dBm
For Scale Type (Lin) = Volts
Remote Command:
:UNIT:POWer DBM|DBMV|DBMA|V|W|A|DBUV|DBUA|DBUVM|DBUAM|DBPT|DBG
:UNIT:POWer?
Remote Command Notes: . The settings of Y Axis Units and Scale Type, affect how the
data is read over the remote interface. When using the remote interface no
units are returned, so you must know what the Y-Axis units are to
44 Chapter 2
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
interpret the results:
Example 1, set the following:
Scale Type (Log)
Y Axis Units, dBm
Scale/Div, 1 dB
Ref Level, 10 dBm
This sets the top line to 10 dBm with each vertical division representing 1
dB. Thus, if a point on trace 1 is on the fifth graticule line from the top, it
represents 5 dBm and will read out remotely as 5.
Example 2, set the following:
Scale Type (Lin)
Y Axis Units, Volts
Ref Level, 100 mV (10 mV/div)
This sets the top line to 100 mV and the bottom line to 0 V, so each vertical
division represents 10 mV. Thus, if a point on trace 1 is on the fifth
graticule line from the top, it represents 50 mV and will read out remotely
as 50.
Example:. UNIT:POW dBmV
UNIT:POW?
2.1.8.1 dBm
Sets the amplitude units to dBm.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBM
Chapter 2 45
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
2.1.8.2 dBmV
Sets the amplitude units to dBmV.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBMV
2.1.8.3 dBmA
Sets the amplitude units to dBmA.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBMA
2.1.8.4 Volts
Sets the amplitude units to volts.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW V
2.1.8.5 Watts
Sets the amplitude units to watts.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW W
2.1.8.6 Amps
Sets the amplitude units to amps.
46 Chapter 2
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
History: Added with firmware revision A.06.00
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW A
2.1.8.7 dBμV
Sets the amplitude units to dBμV.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBUV
2.1.8.8 dBμA
Sets the amplitude units to dBμA.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
History: Added with firmware revision A.06.00
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBUA
2.1.8.9 dBμV/m
Sets the amplitude units to dBμV/m. This is a unit specifically applicable to EMI field
strength measurements. In the absence of a correction factor this unit is treated by the
instrument exactly as though it were dBμV. You must load an appropriate correction factor
using amplitude corrections for this unit to generate meaningful results. Therefore, this
key is grayed out unless one of the corrections are turned on (in Amplitude, Corrections
menu) and Apply Corrections is set to Yes.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Dependencies/
Couplings: If the grayed out key is pressed an error message is generated.
History: Added with firmware revision A.06.00
Chapter 2 47
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBUVM
2.1.8.10 dBμA/m
Sets the amplitude units to dBμA/m. This is a unit specifically applicable to EMI field
strength measurements. In the absence of a correction factor this unit is treated by the
instrument exactly as though it were dBμV. You must load an appropriate correction factor
using amplitude corrections for this unit to generate meaningful results. Therefore, this
key is grayed out unless one of the corrections are turned on (in Amplitude, Corrections
menu) and Apply Corrections is set to Yes.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Dependencies/
Couplings: If the grayed out key is pressed an error message is generated.
History: Added with firmware revision A.06.00
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBUAM
2.1.8.11 dBpT
Sets the amplitude units to dBpT. This is a unit specifically applicable to EMI field
strength measurements. In the absence of a correction factor this unit is treated by the
instrument exactly as though it were dBμV. You must load an appropriate correction factor
using amplitude corrections for this unit to generate meaningful results. Therefore, this
key is grayed out unless one of the corrections are turned on (in Amplitude, Corrections
menu) and Apply Corrections is set to Yes.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Dependencies/
Couplings: If the grayed out key is pressed an error message is generated.
History: Added with firmware revision A.06.00
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBPT
48 Chapter 2
Instrument Functions: A - L
AMPLITUDE / Y Scale
Instrument Functions: A - L
2.1.8.12 dBG
Sets the amplitude units to dBG. This is a unit specifically applicable to EMI field strength
measurements. In the absence of a correction factor this unit is treated by the instrument
exactly as though it were dBμV. You must load an appropriate correction factor using
amplitude corrections for this unit to generate meaningful results. Therefore, this key is
grayed out unless one of the corrections are turned on (in Amplitude, Corrections menu) and
Apply Corrections is set to Yes.
Key Path: AMPLITUDE / Y Scale, More, Y Axis Units
Dependencies/
Couplings: If the grayed out key is pressed an error message is generated.
History: Added with firmware revision A.06.00
Remote Command:
See “Y Axis Units” on page 43.
Example: UNIT:POW DBG</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>AutoCouple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function AutoCouple(obj, WhichParm, AutoCplFlag)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
InputValid = true;
switch WhichParm
  case 0 % Input Attenuation
    s = 'POW:ATT';
  case 1 % RBW
    s = 'BWID';
  case 2 %VBW
    s = 'BWID:VID';
  case 3 % Sweep time
    s = 'SWE:TIME';
  case 4 % Detector Mode
    s = 'DET';
  case 5 % average type
    s = 'AVER:TYPE';
  otherwise
    % warning input parm is invalid
    InputValid = false;
end
if InputValid
  fprintf(interface, [s, ':AUTO ', num2str(AutoCplFlag)]);
end</MCode>
               </Code>
               <Description>sets the coupled status of the parameter designated by WhichParm
WhichParm = 0 --&gt; Attenuation
WhichParm = 1 --&gt; RBW
WhichParm = 2 --&gt; VBW
WhichParm = 3 --&gt; Sweep Time
WhichParm = 4 --&gt; Detector
WhichParm = 5 --&gt; Video Average Type</Description>
            </Method>
            <Method>
               <Name>AutoCoupleAll</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function AutoCoupleAll(obj, AutoCplFlag)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
if AutoCplFlag == true
  fprintf(interface, 'COUP ALL');
else
  for ii = 1:6
    invoke(obj, 'AUTOCPL', ii-1, 0);
  end
end
</MCode>
               </Code>
               <Description>if AutoCplFlag = 1 then all parameters are auto coupled
if AutoCplFlag = 0 then auto coupling of all parameters is turnd off.</Description>
            </Method>
            <Method>
               <Name>AvailAttenVals</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function AvailableAttenVals = AvailAttenVals(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
AvailableAttenVals = [0:5:65];</MCode>
               </Code>
               <Description>Returns Vector with all allowable Attenuation values</Description>
            </Method>
            <Method>
               <Name>CalNow</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function CalNow(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% get interface object
interface=get(obj,'interface');

% set timeout such that alignment has plenty of time.
set(interface,'Timeout',120);

% Perform alignment and wai for it to complete
out = query(interface, 'CAL?');
fprintf(interface, '*WAI');

% check to make sure alignment completed properly
if out ~= 0
  % throw flag alignment was unsuccessful
end

% Reset Timeout
set(interface, 'Timeout', 10);</MCode>
               </Code>
               <Description>This function forces the analyzer to do an alignment</Description>
            </Method>
            <Method>
               <Name>CFToMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function CFToMarker(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
if MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':CENT']);
else
  % warning marker number out of range
end</MCode>
               </Code>
               <Description>This function sets the center frequency to the marker position.</Description>
            </Method>
            <Method>
               <Name>DANL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Val = DANL(obj, PreampOn, Freq)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
[OptNums, ~] = invoke(obj, 'qOPTIONSINSTALLED');
if ~PreampOn || isempty(intersect(OptNums, '1DS')) % does not have preamp
  if Freq &gt;= 1e6 &amp;&amp; Freq &lt; 10e6
    Val = -148;
  elseif Freq &gt;= 10e6 &amp;&amp; Freq &lt; 1e9
    Val = -149;
  elseif Freq &gt;= 1e9 &amp;&amp; Freq &lt; 2e9
    Val = -150;
  elseif Freq &gt;= 2e9 &amp;&amp; Freq &lt; 6e9
    Val = -148;
  elseif Freq &gt;= 6e9 &amp;&amp; Freq &lt; 12e9
    Val = -147;
  elseif Freq &gt;= 12e9 &amp;&amp; Freq &lt; 22e9
    Val = -144;
  elseif Freq &gt;= 22e9 &amp;&amp; Freq &lt; 26.5e9
    Val = -142;
  else
    % Freq Out of Range
    Val = -145;
  end
else % has preamp up to 3GHz that is turned on
  if Freq &gt;= 1e6 &amp;&amp; Freq &lt; 10e6
    Val = -165;
  elseif Freq &gt;= 10e6 &amp;&amp; Freq &lt; 1e9
    Val = -167;
  elseif Freq &gt;= 1e9 &amp;&amp; Freq &lt; 2e9
    Val = -165;
  elseif Freq &gt;= 2e9 &amp;&amp; Freq &lt; 3e9
    Val = -162;
  else
    % Freq Out of Range
    Val = -165
  end
end

</MCode>
               </Code>
               <Description>Gets the DANL value based on frequency and whether or not preamp is on.</Description>
            </Method>
            <Method>
               <Name>DeltaMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function DeltaMarker(obj, MkrOrd, DeltaVal)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
if MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  % Make sure specified marker is in delta mode
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':MODE DELT']);

  % get the position of the reference marker
  temp =  str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:START?']));

  % Move the delta marker the specified value from the reference marker
  % Note when trying these commands directly as shown in the E4440 User's guide
  % they do not work. Do not use this function in code.
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X:STOP ',num2str(temp+DeltaVal)]);
else
  %warning chose marker number is out of range
end</MCode>
               </Code>
               <Description>This sets a delta marker on the screen at the specified frequency difference (or time difference in zero span).
The SCPI commands do not work as stated in the Agilent E4440 User's guide. Do not use this function in code.</Description>
            </Method>
            <Method>
               <Name>FreqInRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function InRange = FreqInRange(obj, WhichFreq, FreqValue)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
Range = invoke(obj, 'FRANGE', WhichFreq);
Min = Range(1);
Max = Range(2);
if FreqValue &gt;= Min &amp;&amp; FreqValue &lt;= Max
  InRange = true;
else
  InRange = false;
end</MCode>
               </Code>
               <Description>queries the analyzer to determine if the specified frequency value is within the limits of the specified frequency type.
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW

FreqValue is specified in hertz</Description>
            </Method>
            <Method>
               <Name>FreqRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = FreqRange(obj, WhichFreq)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface= get(obj, 'interface');
ValidInput = true;
switch WhichFreq
  case 1 % Center Freq
    s = ':FREQ:CENT?';
  case 2 % Start Freq
    s = ':FREQ:STAR?';
  case 3 % Stop Freq
    s = ':FREQ:STOP?';
  case 4 % Span
    s = ':FREQ:SPAN?';
  case 5 % frequency offset
    s = ':DISP:WIND:TRAC:X:OFFS?';
  case 6 % RBW
    s = ':BWID?';
  case 7 % VBW
    s = ':BWID:VID?';
  otherwise %invalid input
    % warning invalid input
    ValidInput = false;
    Range = [];
end
if ValidInput
  MinFreq = str2double(query(interface, [s, ' MIN']));
  MaxFreq = str2double(query(interface, [s, ' MAX']));
  Range = [MinFreq MaxFreq];
end</MCode>
               </Code>
               <Description>queries the min and max of a the frequency specified by WhichFreq
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW</Description>
            </Method>
            <Method>
               <Name>GetOvrDrvAndAlignRqst</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OverLoadFlag, AlignFlag] = GetOvrDrvAndAlignRqst(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface=get(obj,'interface');

temp = str2double(query(interface, 'STAT:QUES:CAL:COND?'));
if temp &gt; 0
  AlignFlag = true;
else
  AlignFlag = false;
end

% Check for overload
tempData = invoke(obj, 'DATA', 1, false);
RefLvl = get(obj, 'RL');
OnedBCompPt = get(obj, 'OneDBcompPt');

minpow = min(tempData);
tempData2 = tempData(tempData &gt;= (minpow + 5));
if isempty(tempData)
  tempData2 = max(tempData);
end

LinPow = 10.^(tempData2./10);
TotLinPow = sum(LinPow);
TotPowdB = 10*log10(TotLinPow);

if max(tempData) &gt; RefLvl || TotPowdB &gt; OnedBCompPt
  OverLoadFlag = true;
else
  OverLoadFlag = false;
end
</MCode>
               </Code>
               <Description>Query status registers to determine whether or not an overload has occurred or an alignment is required.</Description>
            </Method>
            <Method>
               <Name>InitCaptureData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function InitCaptureData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set 
fprintf(interface,':INIT:TCAP');</MCode>
               </Code>
               <Description>Capture Time Data

Initiates the recording of data while in the Spectrum or Waveform
measurements. You must have PSA Option 122 or 140 installed and
have the wideband path selected SENSe:SPECtrum:IFPath WIDE or
SENSe:WAVeform:IFPath WIDE.
Example: INIT:TCAP
Remarks: You must be in the Basic mode to use this command.
Use INSTrument:SELect to set the mode.
History: Added with PSA revision A.06.00
Front Panel
Access: Meas Control, Capture Setup, Capture</Description>
            </Method>
            <Method>
               <Name>INITSA</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function INITSA(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

ST = str2double(query(interface, 'SWE:TIME?'));
set(interface,'Timeout',ST + 2);  
fprintf(interface, 'STAT:OPER:ENAB 8'); %Enable sweeping status flag
fprintf(interface, 'INIT; *WAI'); % initiate sweep and wait for it to complete
dummyCmd = query(interface, 'SYST:ERR?');
set(interface,'Timeout', 10);  </MCode>
               </Code>
               <Description>Start a Sweep/Measurement
Causes instrument to exit the 'idle' state and go to the initiated state.
Once trigger conditions are met the sweep measurement will start.
This only works with SA in Spectrum Analyzer mode.

This may not work when waiting for a trigger due to timeout not being long enough</Description>
            </Method>
            <Method>
               <Name>Marker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Marker(obj, MkrOrd, TurnMarkerOn)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
% Only do selected marker if in range (the E4440 allows up to 4 markers).
if MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  if TurnMarkerOn
    s = [num2str(MkrOrd), ':STAT ON'];
  else
    if MkrOrd == 0
      s = ':AOFF';
    else
      s = [num2str(MkrOrd),':STAT OFF'];
    end
  end
  fprintf(interface, ['CALC:MARK', s]);
end
</MCode>
               </Code>
               <Description>Turns the specified marker on or off
if 0 is the specified marker the all markers are affected
MkrOrd = specified marker
TurnMarkerOn = marker state true = on false = off</Description>
            </Method>
            <Method>
               <Name>MarkerMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function MarkerMode(obj, MkrOrd, MkrMode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
ValidInput = true;
switch MkrMode
  case 0 %off
    ModeStr = 'OFF';
  case 1 %Normal
    ModeStr = 'POS';
  case 2 %Delta
    ModeStr = 'DELT';
  case 3 % Band Power
    ModeStr = 'BAND';
  case 4 % Span
    ModeStr = 'SPAN';
  otherwise % invalid input
    % warning invalid input raise flag
    ValidInput = false;
end
% only attempt to set the marker if a valid mode and number has been selected 
if ValidInput &amp;&amp; MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  if MkrOrd == 0 %Set all markers
    MkrStart = 1;
    MkrEnd = 4;
  else
    MkrStart = MkrOrd;
    MkrEnd = MkrStart;
  end
  for ii = MkrStart:MkrEnd
    fprintf(interface, [':CALC:MARK',num2str(ii),':MODE ',ModeStr])
  end
end</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>MarkerToFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function MarkerToFreq(obj, MkrOrd, FreqVal)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
% check to make sure marker number is in range
if MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  % Make sure specified marker is in Normal mode
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':MODE POS']);

  % Move marker to specified frequency
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X ',num2str(FreqVal)]);
else
  % warning input marker number is not within range.
end</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>MarkerToPeak</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function MarkerToPeak(obj, MkrOrd, DetMode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
ValidInput = true;
switch DetMode
  case 0 % max peak
    str = '';
  case 1 % next highest
    str = ':NEXT';
  case 2 % next Right
    str = ':RIGH';
  case 3 % Next Left
    str = ':LEFT';
  otherwise
    % warning invalid input
    ValidInput = false;
end
if ValidInput &amp;&amp; MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':MAX',str]);
else
  % Warning invalid input
end</MCode>
               </Code>
               <Description>places a marker at the highest peak the next highest peak, the next right peak, or the next left peak
</Description>
            </Method>
            <Method>
               <Name>NumMarkerModes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumModes, ModeNames] = NumMarkerModes(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
NumModes = 5;
ModeNames = {'Off', 'Normal', 'Delta', 'Delta Pair', 'Span Pair'};</MCode>
               </Code>
               <Description>returns the number of available marker modes and the names of those marker modes.</Description>
            </Method>
            <Method>
               <Name>NumMeasWindows</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>NumTraceModes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumModes, ModeNames] = NumTraceModes(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
NumModes = 5;
ModeNames = {'Clear Write', 'Max Hold', 'Min Hold', 'View', 'Blank'};</MCode>
               </Code>
               <Description>returns the number of trace modes and the names of each.
</Description>
            </Method>
            <Method>
               <Name>NumTraces</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Num, IDs] = NumTraces(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
Num = 3;
IDs = {'1', '2', '3'};</MCode>
               </Code>
               <Description>returns the number of traces and the ID for each</Description>
            </Method>
            <Method>
               <Name>OptionNames</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OptionID, OptionNames] = OptionNames(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
OptionID{1} = '106';
OptionNames{1} = 'Bluetooth FM Demodulation';
OptionID{2} = '120';
OptionNames{2} = 'ACPR Dynamic Range Extension';
OptionID{3} = '219';
OptionNames{3} = 'Noise Figure Measurement Personality';
OptionID{4} = '225';
OptionNames{4} = 'Distance to Fault Measurement Personality';
OptionID{5} = '226';
OptionNames{5} = 'Phase Noise Measurement Personality';
OptionID{6} = '227';
OptionNames{6} = 'Cable TV Measurement Personality';
OptionID{7} = '228';
OptionNames{7} = 'Bluetooth Measurement Personality';
OptionID{8} = '229';
OptionNames{8} = 'Modulation Analysis';
OptionID{9} = '252';
OptionNames{9} = 'EDGE Upgrade GSM to Personality';
OptionID{10} = '266';
OptionNames{10} = '8566 Programming Compatibility';
OptionID{11} = '290';
OptionNames{11} = '8590 Programming Compatibility';
OptionID{12} = '304';
OptionNames{12} = 'Bluetooth Premium Bundle';
OptionID{13} = '1AX';
OptionNames{13} = 'RS-232 and Parallel Interface';
OptionID{14} = '1D5';
OptionNames{14} = 'High Stability Frequency Reference';
OptionID{15} = '1D6';
OptionNames{15} = 'Time-Gated Spectrum Analysis';
OptionID{16} = '1DN';
OptionNames{16} = '50 Ohm Tracking Generator';
OptionID{17} = '1DR';
OptionNames{17} = 'Narrow Resolution Bandwidths';
OptionID{18} = '1DS';
OptionNames{18} = 'RF Preamplifier';
OptionID{19} = 'A4H';
OptionNames{19} = 'GPIB and Parallel Interface';
OptionID{20} = 'A4J';
OptionNames{20} = 'IF, Video, and Sweep Ports';
OptionID{21} = 'AYQ';
OptionNames{21} = 'FM Demod/Quasi Peak Detector';
OptionID{22} = 'AYX';
OptionNames{22} = 'Fast Time Domain Sweeps';
OptionID{23} = 'AYZ';
OptionNames{23} = 'External Mixing';
OptionID{24} = 'B72';
OptionNames{24} = 'Enhanced Memory';
OptionID{25} = 'B7B';
OptionNames{25} = 'TV trigger and Pictuer on Screen';
OptionID{26} = 'B7D';
OptionNames{26} = 'Digital Signal Processing and Fast ADC';
OptionID{27} = 'BAA';
OptionNames{27} = 'FM Demodulation';
OptionID{28} = 'BAC';
OptionNames{28} = 'CDMAOne Measurement Personality';
OptionID{29} = 'BAH';
OptionNames{29} = 'GSM Measurement Personality';
OptionID{30} = 'UKB';
OptionNames{30} = 'Low Frequency Extension';
</MCode>
               </Code>
               <Description>Returns the option ID numbers and their associated names. Indexes are mathced in the two vectors.</Description>
            </Method>
            <Method>
               <Name>qAutoCouple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Coupled = qAutoCouple(obj, WhichParm)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
InputValid = true;
switch WhichParm
  case 0 % Input Attenuation
    s = 'POW:ATT';
  case 1 % RBW
    s = 'BWID';
  case 2 %RBW
    s = 'BWID:VID';
  case 3 % Sweep time
    s = 'SWE:TIME';
  case 4 % Detector Mode
    s = 'DET';
  case 5 % average type
    s = 'AVER:TYPE';
  otherwise
    % warning input parm is invalid
    InputValid = false;
    Coupled = [];
end
if InputValid
  Coupled = str2double(query(interface, [s, ':AUTO?']));
end</MCode>
               </Code>
               <Description>queries the coupled status of the parameter designated by WhichParm
WhichParm = 0 --&gt; Attenuation
WhichParm = 1 --&gt; RBW
WhichParm = 2 --&gt; VBW
WhichParm = 3 --&gt; Sweep Time
WhichParm = 4 --&gt; Detector
WhichParm = 5 --&gt; Video Average Type</Description>
            </Method>
            <Method>
               <Name>qDone</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qERR</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function out = qFreq(obj, WhichFreq)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

ValidInput = true;
switch WhichFreq
  case 1 % Center Freq
    s = ':FREQ:CENT?';
  case 2 % Start Freq
    s = ':FREQ:STAR?';
  case 3 % Stop Freq
    s = ':FREQ:STOP?';
  case 4 % Span
    s = ':FREQ:SPAN?';
  case 5 %Offset
    s = ':DISP:WIND:TRAC:X:OFFS?';
  case 6 % RBW
    s = ':BWID?';
  case 7 % VBW
    s = ':BWID:VID?';
  otherwise %invalid input
    % warning invalid input
    ValidInput = false;
    out = [];
end
if ValidInput
  out = str2double(query(interface, s));
end</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qMeasModesInstalled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MeasModeID, idx] = qMeasModesInstalled(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

PotentialMeasModes = {'SA', 'BASIC', 'CDMA', 'CDMA1XEV', 'CDMA2K', 'EDGEGSM',...
  'LINK', 'NADC', 'NFIGURE', 'PDC', 'PNOISE', 'TDSCDMA', 'WCDMA', 'MAN',...
  'Cable Fault'};

InstalledModes = query(interface, 'INST:CAT?');
idx = [];
for ii = 1:length(PotentialMeasModes)
  if ~isempty(findstr(PotentialMeasModes{ii}, InstalledModes))
    idx = [idx ii];
  end
end

MeasModeID = PotentialMeasModes(idx);</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qMkrAmp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function MarkerAmp = qMkrAmp(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  MarkerAmp = str2double(query(interface, [':CALC:MARK', num2str(MkrOrd), ':Y?']));
else
  % warning requested marker number is out of range
  MarkerAmp = [];
end</MCode>
               </Code>
               <Description>queries the amplitude of the specified marker
</Description>
            </Method>
            <Method>
               <Name>qMkrDelta</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function DeltaVal = qMkrDelta(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'qMKMODE', MkrOrd);
  if ModeNum == 3 % delta
    DeltaVal = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X?']));
  else
    % warning marker is not in delta mode
    DeltaVal = [];
  end
else
  % marker number out of range
  DeltaVal = [];
end</MCode>
               </Code>
               <Description>queries the distance between markers must be in delta mode.</Description>
            </Method>
            <Method>
               <Name>qMkrFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Freq = qMkrFreq(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'qMKMODE', MkrOrd);
  if ModeNum == 2 % Normal
    Freq = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X?']));
  else
    % warning marker is not in Normal mode
    Freq = [];
  end
else
  % marker number out of range
  Freq = [];
end</MCode>
               </Code>
               <Description>queries the frequncy value of the currnet marker must be in normal mode.</Description>
            </Method>
            <Method>
               <Name>qMkrMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ModeNum, MkrModeID] = qMkrMode(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

PossibleModeID = {'OFF', 'POS', 'DEL', 'BAN', 'SPA'};

if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  MkrModeID = query(interface, ['CALC:MARK',num2str(MkrOrd),':MODE?']);
  temp = {MkrModeID(1:3)};
  [~, ~, ModeNum] = intersect(temp, PossibleModeID);
else
  % marker number out of range
  ModeNum = [];
  MkrModeID = [];
end</MCode>
               </Code>
               <Description>queries the marker mode.</Description>
            </Method>
            <Method>
               <Name>qMkrPntPos</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function PointPosition = qMkrPntPos(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'qMKMODE', MkrOrd);
  if ModeNum == 2 % Normal
    PointPosition = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS?']));
  elseif ModeNum == 3 % Delta
    RefPoint = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS:STAR?']));
    DeltaPoint = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS:STOP?']));
    PointPosition = [RefPoint DeltaPoint];
  else
    % warning marker is not in appropriate mode
    PointPosition = [];
  end
else
  % marker number out of range
  PointPosition = [];
end</MCode>
               </Code>
               <Description>returns the point position of the marker also returns the position of the delta and ref markers if delta mode. 

This function does not work for Delta mode, as the SCPI commands for finding ref and delta positions do not work as stated in the E4440 Manual
It will work for markers in normal mode.</Description>
            </Method>
            <Method>
               <Name>qOptionsInstalled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AvailOptIDs, AvailOptNames] = qOptionsInstalled(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
InstalledOpts = query(interface, 'SYST:OPT?');

[OptionID, OptionNames] = invoke(obj, 'OptionNames');

idx = [];
for ii = 1:length(OptionID)
  if ~isempty(findstr(InstalledOpts, OptionID{ii}))
    idx = [idx ii];
  end
end
AvailOptIDs = OptionID(idx);
AvailOptNames = OptionNames(idx);</MCode>
               </Code>
               <Description>Query which options are available on the E4440 Currently in use</Description>
            </Method>
            <Method>
               <Name>qPeakTracePnt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [freq, amp] = qPeakTracePnt(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');
% Get the current sweep time and set time out to greater than sweep time to
% avoid time out errors
ST = str2double(query(interface, 'SWE:TIME?'));

set(interface,'Timeout',ST + 2);
% Change instrument mode to spectrum analyzer
%fprintf(interface,':INST:NSEL 1');

% Set the analyzer into single sweep mode
%fprintf(interface,':INIT:CONT OFF');

% Trigger the sweep and wait for it to complete
fprintf(interface,':INIT:IMM;*WAI');

% Get the peak data back
fprintf(interface,':CALC:MARK:MAX')
freq = str2double(query(interface,':CALC:MARK:X?'));
amp = str2double(query(interface,':CALC:MARK:Y?'));

% Reset timeout
set(interface,'Timeout',10);

%fprintf(interface,':INIT:CONT ON');
</MCode>
               </Code>
               <Description>queries the peak list the meets the peak threshold and peak excursion criteria.

Iutput parameters: none
Output parameters: two column vectors, the first is the frequency point an the second is the amplitude peak value.

 example: [freq amp] = invoke(mxa_handle, 'qPeakTracePnt')</Description>
            </Method>
            <Method>
               <Name>qPreampMax</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function PreampMax = qPreampMax(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
SAOptions = query(interface, 'SYST:OPT?');
if ~isempty(findstr(SAOptions, '110'))
  PreampMax = 50e9; % 50 GHz
elseif ~isempty(findstr(SAOptions, '1DS'))
  PreampMax = 3e9; % 3 GHz
else
  PreampMax = 0; % no Preamp
end</MCode>
               </Code>
               <Description>This method queries the analyzer to find out if a preamp is installed. if there is a preamp this method returns the max frequency for which it applies, if no preamp is available it returns a zero.</Description>
            </Method>
            <Method>
               <Name>qRANGES</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinVal, MaxVal, IncVal] = qRANGES(obj, WhichParm)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
switch WhichParm
  case 0 % Ref Level
    MinVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:RLEV? MIN'));
    MaxVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:RLEV? MAX'));
    IncVal = 0.5;
  case 1 % Attenuation
    MinVal = 0;
    MaxVal = 65;
    IncVal = 5;
  case 2 % Y Scale Per Div
    MinVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:PDIV? MIN'));
    MaxVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:PDIV? MAX'));
    IncVal = 1;
  otherwise 
    %invalid input
    MinVal = [];
    MaxVal = [];
    IncVal = [];
end


</MCode>
               </Code>
               <Description>Given the current analyzer settings this function queries for the min, max and increment for each of the following parameters (WhichParm)
WhichParm = 0 --&gt; Reference Level
WhichParm = 1 --&gt; Attenuation
WhichParm = 2 --&gt; Y-Axis Scale per division</Description>
            </Method>
            <Method>
               <Name>qRLRANGE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function out = qRLRANGE(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
MinRL = str2double(query(interface,':DISP:WIND:TRAC:Y:RLEV? MIN'));
MaxRL = str2double(query(interface,':DISP:WIND:TRAC:Y:RLEV? MAX'));
out = [MinRL : .5 : MaxRL];</MCode>
               </Code>
               <Description>query available reference level values</Description>
            </Method>
            <Method>
               <Name>qTraceMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Mode = qTraceMode(obj, TraceOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
[NumTraces, ~] = invoke(obj, 'NumTraces');
interface = get(obj, 'interface');
PotentialModes = {'WRIT', 'MAXH', 'MINH', 'VIEW', 'BLAN'};

if TraceOrd &gt;= 1 &amp;&amp; TraceOrd &lt;= NumTraces
  temp = query(interface, [':TRAC',num2str(TraceOrd),':MODE?']);
  temp = {temp(1:4)};
  [~, ~, temp2] = intersect(temp, PotentialModes);
  Mode = temp2-1;
else
  % Trace number out of range
  Mode = [];
end
  
  </MCode>
               </Code>
               <Description>queries the SA for the mode of the specified trace</Description>
            </Method>
            <Method>
               <Name>qTRIGDELAY</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qTRIGLEVEL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>QuerySCPI</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function res=QuerySCPI(obj,cmd)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

interface=get(obj,'interface');

res=query(interface,cmd);</MCode>
               </Code>
               <Description>Query_SCPI sends an SCPI string to the instrument and returns its response.

Input parameters: SCPI string
Output parameters: response string from the instrument</Description>
            </Method>
            <Method>
               <Name>QuickCalNow</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function QuickCalNow(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
invoke(obj, 'CalNow');</MCode>
               </Code>
               <Description>Runs complete alignment. Does the same as CalNow
</Description>
            </Method>
            <Method>
               <Name>RCLS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>RCLT</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>RefLevelToMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function RefLevelToMarker(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':RLEV']);
else
  % warning invalid input
end</MCode>
               </Code>
               <Description>sets the reference level to the amplitude of the specified marker</Description>
            </Method>
            <Method>
               <Name>RL2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SAPeakAcq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [freq,amp] = SAPeakAcq(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Set the analyzer into single sweep mode
fprintf(interface,':INIT:CONT OFF');

% Trigger the sweep and wait for it to complete
fprintf(interface,':INIT:IMM;*WAI');

% Get the data back
peaks = str2num(query(interface,':TRAC:MATH:PEAK?'));

freq = peaks(1:2:end-1)';
amp = peaks(2:2:end)';

fprintf(interface,':INIT:CONT ON');
</MCode>
               </Code>
               <Description>getPeaks queries the peak list the meets the peak threshold and peak excursion criteria.

Iutput parameters: none
Output parameters: two column vectors, the first is the frequency points an the second is the amplitude peak values.

 example: [freq amp] = invoke(mxa_handle, 'SAPeakAcq'')

FOR USE WITH MXA</Description>
            </Method>
            <Method>
               <Name>SAVES</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SAVET</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SCALEPERDIV2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SetFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SetFreq(obj, WhichFreq, FreqValue)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

% Check to make sure freq value is in range
if invoke(obj, 'FREQINRANGE', WhichFreq, FreqValue)
  ValidInput = true;
  switch WhichFreq
    case 1 % Center Freq
      s = ':FREQ:CENT ';
    case 2 % Start Freq
      s = ':FREQ:STAR ';
    case 3 % Stop Freq
      s = ':FREQ:STOP ';
    case 4 % Span
      s = ':FREQ:SPAN ';
    case 5 %Offset
      s = ':DISP:WIND:TRAC:X:OFFS ';
    case 6 % RBW
      s = ':BWID ';
    case 7 % VBW
      s = ':BWID:VID ';
    otherwise %invalid input
      % warning invalid input
      ValidInput = false;
  end
  if ValidInput
    fprintf(interface, [s, num2str(FreqValue)])
  end
else
  % warning specified frequency is not within the allowable range.
end</MCode>
               </Code>
               <Description>Sets the specified frequency (WhichFreq) type to the specified value (FreqValue).
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW

FreqValue is specified in hertz</Description>
            </Method>
            <Method>
               <Name>SetMkrByPnt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SetMkrByPnt(obj, MkrOrd, TracePnt)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'qMKMODE', MkrOrd);
  if ModeNum == 2 % Normal
    fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS ',num2str(TracePnt)]);
  else
    % warning marker is not in normal mode
  end
else
  % marker number out of range
end</MCode>
               </Code>
               <Description>sets the position of the specified marker in normal mode the point position specified. </Description>
            </Method>
            <Method>
               <Name>SetOvrDrvAndAlignRqst</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SetOvrDrvAndAlignRqst(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Get interface obj
interface=get(obj,'interface');

% set decimal representations of status bits
AlignRqst = 256;
OvrDrv = 8; %Second IF Overload
AllBits = 32767;
NoBits = 0;

% SCPI Command headers
Hdr1 = 'STAT:QUES:CAL:';
Hdr2 = 'STAT:QUES:POW:';
% Send commands to Analyzer to set up status registers
fprintf(interface,[Hdr1, 'PTR ', num2str(AlignRqst)]);
fprintf(interface,[Hdr1, 'NTR ', num2str(NoBits)]);
fprintf(interface,[Hdr1, 'ENAB ', num2str(AlignRqst)]);
fprintf(interface,[Hdr2, 'PTR ', num2str(OvrDrv)]);
fprintf(interface,[Hdr2, 'NTR ', num2str(NoBits)]);
fprintf(interface,[Hdr2, 'ENAB ', num2str(AllBits)]);

% Clear questionable integrity register
ret = str2num(query(interface, 'STAT:QUES:INT?'));
</MCode>
               </Code>
               <Description>Sets up the status registers to report both an over-drive condition or an alignment request. No other conditions are monitored. use GetOvrDrvand AlignRqst to query registers.</Description>
            </Method>
            <Method>
               <Name>SpanToMarkerDelta</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SpanToMarkerDelta(obj, MkrOrd)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  [ModeNum, ~] = invoke(obj, 'qMKMODE', MkrOrd);
  if ModeNum == 3 % Delta
    fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':SPAN']);
  else
    %marker must be in delta mode
  end
else
  % warning invalid input
end
</MCode>
               </Code>
               <Description>sets the span based on the separation of the delta markers</Description>
            </Method>
            <Method>
               <Name>SPVAL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinSpan, MaxSpan] = SPVAL(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
MinSpan = str2double(query(interface, ':FREQ:SPAN? MIN'));
MaxSpan = str2double(query(interface, ':FREQ:SPAN? MAX'));</MCode>
               </Code>
               <Description>queries for the min and max allowable spans</Description>
            </Method>
            <Method>
               <Name>SweepTimeRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = SweepTimeRange(obj, qInst, Span)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
if qInst || exist('Span', 'var') == 0
  Span = str2double(query(interface, ':FREQ:SPAN?'));
end
if Span == 0
  Range = [50e-9 4000];
else
  Range = [.001 4000];
end</MCode>
               </Code>
               <Description>Provides the available range of sweep times for the 4440</Description>
            </Method>
            <Method>
               <Name>SwpPntRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = SwpPntRange(obj, qInst, Span)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
if qInst || exist('Span', 'var') == 0
  Span = str2double(query(interface, ':FREQ:SPAN?'));
end
if Span == 0
  Range = [2 8192];
else
  Range = [101 8192];
end</MCode>
               </Code>
               <Description>query the available sweep point range for the e4440</Description>
            </Method>
            <Method>
               <Name>SYSMESSAGE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SYSMESSAGE(obj, Msg)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
set(obj, 'SATitle', ['"',Msg,'"']);</MCode>
               </Code>
               <Description>display message on instrument screen</Description>
            </Method>
            <Method>
               <Name>TakeSweep</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function TakeSweep(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface=get(obj,'interface');
ST = str2double(query(interface, 'SWE:TIME?'));
set(interface,'Timeout',ST + 2);  
fprintf(interface, 'INIT;*WAI');
err = query(interface, 'SYST:ERR?');
set(interface,'Timeout', 10);  </MCode>
               </Code>
               <Description>tells analyzer to begin a sweep holds actions until swepp is complete.</Description>
            </Method>
            <Method>
               <Name>TraceData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function data=TraceData(obj, TraceOrd, NewTrace)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.


% Get the interface object
interface=get(obj,'interface');
ST = str2double(query(interface, 'SWE:TIME?'));

if TraceOrd &gt; 0 &amp;&amp; TraceOrd &lt;= 3
  % Change instrument mode to spectrum analyzer and set timeout to &gt; ST
  set(interface,'Timeout',ST + 2);  

  % Tell it the precision
  fprintf(interface,':FORM:DATA REAL,32');

  % Set the analyzer into single sweep mode
  fprintf(interface,':INIT:CONT OFF');

  % Trigger the sweep and wait for it to complete if a new sweep is requested
  if NewTrace
    fprintf(interface,':INIT:IMM;*WAI');
  end
  
  % Get the data back
  fprintf(interface,[':TRACE:DATA? TRACE', num2str(TraceOrd)]);
  data=binblockread(interface,'float');
  
  % reset the timeout
  set(interface, 'Timeout', 10);
else
  % warning the SA only has three traces. Invalid trace number requested
  data = [];
end


</MCode>
               </Code>
               <Description>SATraceAcq method gets the swept SA trace data

Iutput parameters: none
Output parameters: one column vector with trace data</Description>
            </Method>
            <Method>
               <Name>TraceMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function TraceMode(obj, TraceOrd, TraceMode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
[NumTraces, ~] = invoke(obj, 'NumTraces');
interface = get(obj, 'interface');

if TraceOrd &gt;= 1 &amp;&amp; TraceOrd &lt;= NumTraces
  ValidInput = true;
  switch TraceMode
    case 0 % clear write
      sCmd = 'WRIT';
    case 1 % Max Hold
      sCmd = 'MAXH';
    case 2 % Min Hold
      sCmd = 'MINH';
    case 3 % View
      sCmd = 'VIEW';
    case 4
      sCmd = 'BLAN';
    otherwise
      % warning invalid input
      ValidInput = false;
  end
  if ValidInput
    fprintf(interface, [':TRAC',num2str(TraceOrd),':MODE ',sCmd]);
  end
else
  % trace number out of range
end</MCode>
               </Code>
               <Description>sets the trace mode of the specified trace
TraceMode Ord
0 = Clear Write
1 = Max Hold
3 = Min Hold
4 = View
5 = Blank</Description>
            </Method>
            <Method>
               <Name>TRIGDELAY</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>WriteSCPI</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function WriteSCPI(obj,cmd)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

interface=get(obj,'interface');

fprintf(interface,cmd);</MCode>
               </Code>
               <Description>Write_SCPI sends an SCPI string to the instrument

Input parameters: SCPI string
Output parameters: none

</Description>
            </Method>
            <Method>
               <Name>XAxisUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>YAxisUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>