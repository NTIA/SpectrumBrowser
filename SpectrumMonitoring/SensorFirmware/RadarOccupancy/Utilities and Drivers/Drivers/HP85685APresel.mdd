<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>C:\Program Files\MATLAB\R2009b\toolbox\instrument\instrument\drivers\RSMS4G_5To18GHzPresel.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Switch</InstrumentType>
   <InstrumentManufacturer>Hewlett-Packard</InstrumentManufacturer>
   <InstrumentModel>HP85685A</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify>ID</Identify>
   <Reset>IP</Reset>
   <Selftest/>
   <Error>ERROR</Error>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
set(interface, 'OutputBufferSize', 512);
set(interface, 'InputBufferSize', 512);
set(interface, 'ByteOrder', 'littleEndian');
set(interface, 'TimeOut', 10);
fclose(interface);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Bypass</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>BYPASS</ConfigureCommand>
                     <QueryCommand>BYPASS?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets the bypass to on or off. Only the second port can be used when in bypass mode.</Description>
            </Property>
            <Property>
               <Name>CF</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CF</ConfigureCommand>
                     <QueryCommand>CF?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.00995008E9" Min="20.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>20.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>iGenAtten</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iface = get(obj, 'interface');
propertyValue = str2double(query(iface, 'AT?'));</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iface = get(obj, 'interface');
fprintf(iface, ['AT ',num2str(propertyValue)])</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>3.0</Value>
                     <Value>10.0</Value>
                     <Value>13.0</Value>
                     <Value>20.0</Value>
                     <Value>23.0</Value>
                     <Value>30.0</Value>
                     <Value>33.0</Value>
                     <Value>40.0</Value>
                     <Value>43.0</Value>
                     <Value>50.0</Value>
                     <Value>53.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>  Sets the attenuation to the value (in dB) specified by user or queries the current attenuation
</Description>
            </Property>
            <Property>
               <Name>iGenAttenChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenAtten');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iface = get(obj, 'interface');
fprintf(iface, ['AT ',num2str(propertyValue)])

% check the setting
SetAtten = get(obj, 'iGenAtten');
if SetAtten ~= propertyValue
  error('Presel:Property:Atten:SettingIncorrect',...
    'The preselector attenuation is not set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>3.0</Value>
                     <Value>10.0</Value>
                     <Value>13.0</Value>
                     <Value>20.0</Value>
                     <Value>23.0</Value>
                     <Value>30.0</Value>
                     <Value>33.0</Value>
                     <Value>40.0</Value>
                     <Value>43.0</Value>
                     <Value>50.0</Value>
                     <Value>53.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>20</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the attenuation
If setting the property then it checks to see that it is set properly.
If it is not then an error is raised
If an error occurs during a query then an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenHasNullInput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 0;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>returns whether or not it is possible to set the preselector to no input port.</Description>
            </Property>
            <Property>
               <Name>iGenHighestFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 2009950080;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.00995008E9" Min="2.00995008E9"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2.00995008E9</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Query the highest possible frequency</Description>
            </Property>
            <Property>
               <Name>iGenInputPort</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
temp = str2double(query(IFace, 'I?'));
propertyValue = temp-1;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');

fprintf(IFace, ['I ',num2str(propertyValue+1)]);</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Ant Port 1" Value="0"/>
                     <Enum Name="Ant Port 2" Value="1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the desired input port or queries which input port is active.
0 indicates no port. Before Query ot this function user must make sure the CF is set as desired. If it is not this property may return an incorrect value.</Description>
            </Property>
            <Property>
               <Name>iGenInputPortChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenInputPort');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');

% convert to double if input is a string
if ischar(propertyValue)
  propertyValue = str2double(propertyValue);
end

fprintf(IFace, ['I ',num2str(propertyValue+1)]);
% check the setting

SetPort = get(obj, 'iGenInputPort');
if SetPort ~= propertyValue
  error('Presel:Property:InputPort:SettingIncorrect',...
    'The preselector input port is not set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Ant Port 1" Value="0"/>
                     <Enum Name="Ant Port 2" Value="1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the antenna port.
If setting the property then it is checked to make sure it was set properly.
If it not set properly or a modbus error occurs then an error is raised.
If an error occurs during a query then the empty set is returned and an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenInstDescID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 'HP85685A GPIB';</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the name of the instrument.
This is the same name as found in the miscellaneous function
getInstListAndDrivers.</Description>
            </Property>
            <Property>
               <Name>iGenModelName</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 'HP85685A';</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the model name of the preseletcor. This is the same as 
InstDescID without the IP on the end. This model name is used in the
SetVCFPath fuction in the YIG Tracker driver so the name it returns must match 
what this function expects.</Description>
            </Property>
            <Property>
               <Name>iGenNumPaths</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 17;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>17</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Specifies the possible number of paths including no path
Returns the number of separate paths</Description>
            </Property>
            <Property>
               <Name>Path</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = [];</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="None" Value="0"/>
                     <Enum Name="Straight Through" Value="1"/>
                     <Enum Name="Band Pass 0.5-1 GHz" Value="2"/>
                     <Enum Name="Band Pass 1-2 GHz" Value="3"/>
                     <Enum Name="Band Pass 2-4 GHz" Value="4"/>
                     <Enum Name="Band Pass 4-8 GHz" Value="5"/>
                     <Enum Name="Band Pass 8-12 GHz" Value="6"/>
                     <Enum Name="Band Pass 12-18 GHz" Value="7"/>
                     <Enum Name="TNBL 0.5-2 GHz" Value="8"/>
                     <Enum Name="TNBL 2-18 GHz" Value="9"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the RF preselector path as specified by the argument "PathVal", where the value
can be any value from 0 to (Number of paths).  A value of 0 designates that no RF Path is selected.</Description>
            </Property>
            <Property>
               <Name>SerialNum</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 1234567;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1234567</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Span</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SP</ConfigureCommand>
                     <QueryCommand>SP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>iGenAllPathProperties</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FilterType, FilterName, PathName, StartFreq, StopFreq, BandWidth, Amplifier, PathGain, NoiseFigure, CompressPt, ThrdOrdInt] = iGenAllPathProperties(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

FilterType{1} = 'BYP';
FilterName{1} = 'Bypass';
PathName{1} = 'Bypass (Ant Port 2 Only)';
StartFreq{1} = 0;
StopFreq{1} = 2.2e9;
BandWidth{1} = 2.2e9;
Amplifier{1} = 0;
PathGain{1} = 0;
NoiseFigure{1} = 0;
CompressPt{1} = 0;
ThrdOrdInt{1} = 0;

FilterType{2} = 'BPF';
FilterName{2} = 'Band-pass';
PathName{2} = 'BP 20-10,099Hz';
StartFreq{2} = 20;
StopFreq{2} = 10099;
BandWidth{2} = 10079;
Amplifier{2} = 1;
PathGain{2} = 20;
NoiseFigure{2} = 15;
CompressPt{2} = 0;
ThrdOrdInt{2} = 0;

FilterType{3} = 'BPF';
FilterName{3} = 'Band-pass';
PathName{3} = 'BP 10.1-74 kHz';
StartFreq{3} = 10100;
StopFreq{3} = 73999;
BandWidth{3} = 63899;
Amplifier{3} = 1;
PathGain{3} = 20;
NoiseFigure{3} = 15;
CompressPt{3} = 0;
ThrdOrdInt{3} = 0;

FilterType{4} = 'BPF';
FilterName{4} = 'Band-pass';
PathName{4} = 'BP 74-123,500 kHz';
StartFreq{4} = 74000;
StopFreq{4} = 197499;
BandWidth{4} = 123499;
Amplifier{4} = 1;
PathGain{4} = 20;
NoiseFigure{4} = 15;
CompressPt{4} = 0;
ThrdOrdInt{4} = 0;

FilterType{5} = 'BPF';
FilterName{5} = 'Band-pass';
PathName{5} = 'BP 197.5-525 kHz';
StartFreq{5} = 197500;
StopFreq{5} = 524999;
BandWidth{5} = 327499;
Amplifier{5} = 1;
PathGain{5} = 20;
NoiseFigure{5} = 15;
CompressPt{5} = 0;
ThrdOrdInt{5} = 0;

FilterType{6} = 'BPF';
FilterName{6} = 'Band-pass';
PathName{6} = 'BP 525-1025 kHz';
StartFreq{6} = 525000;
StopFreq{6} = 1024998;
BandWidth{6} = 499998;
Amplifier{6} = 1;
PathGain{6} = 20;
NoiseFigure{6} = 15;
CompressPt{6} = 0;
ThrdOrdInt{6} = 0;

FilterType{7} = 'BPF';
FilterName{7} = 'Band-pass';
PathName{7} = 'BP 1.025-1.96 MHz';
StartFreq{7} = 1024999;
StopFreq{7} = 1959997;
BandWidth{7} = 934998;
Amplifier{7} = 1;
PathGain{7} = 20;
NoiseFigure{7} = 15;
CompressPt{7} = 0;
ThrdOrdInt{7} = 0;

FilterType{8} = 'TNBL';
FilterName{8} = 'Tunable YIG';
PathName{8} = 'TN 1.96-5.83 MHz';
StartFreq{8} = 1959998;
StopFreq{8} = 5829997;
BandWidth{8} = 661300;
Amplifier{8} = 1;
PathGain{8} = 20;
NoiseFigure{8} = 15;
CompressPt{8} = 0;
ThrdOrdInt{8} = 0;

FilterType{9} = 'TNBL';
FilterName{9} = 'Tunable YIG';
PathName{9} = 'TN 5.83-17.33 MHz';
StartFreq{9} = 5829998;
StopFreq{9} = 17329990;
BandWidth{9} = StopFreq{9} - StartFreq{9};
Amplifier{9} = 1;
PathGain{9} = 20;
NoiseFigure{9} = 15;
CompressPt{9} = 0;
ThrdOrdInt{9} = 0;

FilterType{10} = 'TNBL';
FilterName{10} = 'Tunable YIG';
PathName{10} = 'TN 17.33-28.73 MHz';
StartFreq{10} = 17329991;
StopFreq{10} = 28729990;
BandWidth{10} = StopFreq{10} - StartFreq{10};
Amplifier{10} = 1;
PathGain{10} = 20;
NoiseFigure{10} = 15;
CompressPt{10} = 0;
ThrdOrdInt{10} = 0;

FilterType{11} = 'TNBL';
FilterName{11} = 'Tunable YIG';
PathName{11} = 'TN 28.73-51.73 MHz';
StartFreq{11} = 28729991;
StopFreq{11} = 51729981;
BandWidth{11} = StopFreq{11} - StartFreq{11};
Amplifier{11} = 1;
PathGain{11} = 20;
NoiseFigure{11} = 15;
CompressPt{11} = 0;
ThrdOrdInt{11} = 0;

FilterType{12} = 'TNBL';
FilterName{12} = 'Tunable YIG';
PathName{12} = 'TN 51.73-97.83 MHz';
StartFreq{12} = 51729982;
StopFreq{12} = 97829995;
BandWidth{12} = StopFreq{12} - StartFreq{12};
Amplifier{12} = 1;
PathGain{12} = 20;
NoiseFigure{12} = 15;
CompressPt{12} = 0;
ThrdOrdInt{12} = 0;

FilterType{13} = 'TNBL';
FilterName{13} = 'Tunable YIG';
PathName{13} = 'TN 97.83-152.33 MHz';
StartFreq{13} = 97829996;
StopFreq{13} = 152329991;
BandWidth{13} = StopFreq{13} - StartFreq{13};
Amplifier{13} = 1;
PathGain{13} = 20;
NoiseFigure{13} = 15;
CompressPt{13} = 0;
ThrdOrdInt{13} = 0;

FilterType{14} = 'TNBL';
FilterName{14} = 'Tunable YIG';
PathName{14} = 'TN 152.33-216.33 MHz';
StartFreq{14} = 152329992;
StopFreq{14} = 216329927;
BandWidth{14} = StopFreq{14} - StartFreq{14};
Amplifier{14} = 1;
PathGain{14} = 20;
NoiseFigure{14} = 15;
CompressPt{14} = 0;
ThrdOrdInt{14} = 0;

FilterType{15} = 'TNBL';
FilterName{15} = 'Tunable YIG';
PathName{15} = 'TN 216.33-332.23 MHz';
StartFreq{15} = 216329928;
StopFreq{15} = 332229967;
BandWidth{15} = StopFreq{15} - StartFreq{15};
Amplifier{15} = 1;
PathGain{15} = 20;
NoiseFigure{15} = 15;
CompressPt{15} = 0;
ThrdOrdInt{15} = 0;

FilterType{16} = 'TNBL';
FilterName{16} = 'Tunable YIG';
PathName{16} = 'TN 332.23-500 MHz';
StartFreq{16} = 332229968;
StopFreq{16} = 499999899;
BandWidth{16} = StopFreq{16} - StartFreq{16};
Amplifier{16} = 1;
PathGain{16} = 20;
NoiseFigure{16} = 15;
CompressPt{16} = 0;
ThrdOrdInt{16} = 0;

FilterType{17} = 'TNBL';
FilterName{17} = 'Tunable YIG';
PathName{17} = 'TN 0.5-2 GHz';
StartFreq{17} = 499999900;
StopFreq{17} = 2009950080;
BandWidth{17} = StopFreq{17} - StartFreq{17};
Amplifier{17} = 1;
PathGain{17} = 20;
NoiseFigure{17} = 15;
CompressPt{17} = 0;
ThrdOrdInt{17} = 0;</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>iGenGotNoiseDiode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NDPresent, PortNum, AvgENR] = iGenGotNoiseDiode(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NDPresent = 0;
PortNum = [];
AvgENR = [];</MCode>
               </Code>
               <Description>queries the preselector to find out if it has a noise diode built in. If it does this function also returns the port number of the noise diode and the average ENR. If no nosie diode is present this function returns the empty set for the port number and ENR.</Description>
            </Method>
            <Method>
               <Name>iGenInit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenInit(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

fprintf(interface, 'IP');</MCode>
               </Code>
               <Description>This function forces an instrument preset. 
The HP85685 starts up with the following parameters
CF = 190MHz
Span = 70MHz
Atten = 20
Port = 2
Bypass = off
</Description>
            </Method>
            <Method>
               <Name>iGenMaxAttenuation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MaxAtten, AttenInc] = iGenMaxAttenuation(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
MaxAtten = 50;
AttenInc = 10;</MCode>
               </Code>
               <Description>This command returns the maximum available attenuation and how the attenuation can be incremented</Description>
            </Method>
            <Method>
               <Name>iGenNoiseDiodeState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function NDState = iGenNoiseDiodeState(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

NDState = false;

if RaiseError
  error('Presel:Function:NoiseDiodeState:OptionAbsent',...
    'The HP85685 does not have an internal noise diode');
end</MCode>
               </Code>
               <Description>Returns the current state of the power to the noise diode, where 0 = noise diode off and
1 = noise diode on, -1 indicates an error because no noise diode is present.</Description>
            </Method>
            <Method>
               <Name>iGenNumInputPorts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumPorts, PortNames] = iGenNumInputPorts(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NumPorts = 2;
PortNames = {'Ant Port 1', 'Ant Port 2'};</MCode>
               </Code>
               <Description>This function returns the number of input ports and their names. The names must be in the same order as they are set in InputPort and be set as valid inputs to the InputPort property.</Description>
            </Method>
            <Method>
               <Name>iGenProbeTemp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function degC = iGenProbeTemp(obj, WhichProbe, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% warning this preselector does not have temp probes
degC = [];

if ~exist('RaiseError', 'var')
  RaiseError = false;
end


if RaiseError
  error('Presel:Function:ProbeTemp:OptionAbsent',...
    'The HP85685 does not have temperature probes');
end</MCode>
               </Code>
               <Description>' This function returns the temperature value of the selected probe, WhichProbe.
' For the Presel4Gp5_18 Preselector, there are 3 temperature probes (numbered 0 to 2) as follows:
' Probe 0:  Enclosure
' Probe 1:  YIG 0.5-2.0GHz
' Probe 2:  Low Noise Amplifier</Description>
            </Method>
            <Method>
               <Name>iGenSetNoiseDiode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetNoiseDiode(obj, On, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% warning this preselector does not have noise diode.

% create RaiseError and ChkResult if they are not input. The default for
% these inputs is false.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

if RaiseError
  error('Presel:Function:NoiseDiodeState:OptionAbsent',...
    'The HP85685 does not have an internal noise diode');
end</MCode>
               </Code>
               <Description>Designates, by argument SetState, whether to turn the power to the noise diode on or off,
where 0 = off and 1 = on.  If this subroutine is called when there is no noise diode present
and error is passed via the object of type clsCallBack.
If a terminated path is hardwired into the preselector, this subroutine will automatically execute
the proper switching to put the terminator into the path when the noise diode is turned off
by calling this subroutine with the argument "SetState" set to 0.</Description>
            </Method>
            <Method>
               <Name>iGenTempProbes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumProbes, ProbeIDs] = iGenTempProbes(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
NumProbes = 0;
ProbeIDs = [];</MCode>
               </Code>
               <Description>Specifies the possible temperature probes, returns the number of available probes and their IDS</Description>
            </Method>
            <Method>
               <Name>iGenUniversalGetPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StartFreq, StopFreq, FilterType, FilterName] = iGenUniversalGetPath(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

IFace = get(obj, 'interface');

StartFreq = str2double(query(IFace, 'FA?'));
StopFreq = str2double(query(IFace, 'FB?'));

BypassOn = str2double(query(IFace, 'BYPASS?'));
if ~BypassOn
  if StopFreq &lt;= 1959998
    FilterType = 'BPF';
    FilterName = 'Band-pass';
  else
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
  end
else
  FilterType = 'BYP';
  FilterName = 'Bypass';
end</MCode>
               </Code>
               <Description>This function returns the set path in the form of minimum and maximum freqeuncies and the filter type for the returned path number.

If RaiseError = true errors will be raised for modbus errors if it is false and errors occur empty sets will be returned for all the output arguments.</Description>
            </Method>
            <Method>
               <Name>iGenUniversalPathProperties</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FiltType, FilterName, PathName, f1, f2, BW, Amp, G, NF, CompPt, ThrdOrd] = iGenUniversalPathProperties(obj, CenterFreq, FilterType, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
ItWorked = true;
CenterFreq = round(CenterFreq)
switch FilterType
  case 'BYP'
    PathNum = 0;
  case 'BPF'
    if CenterFreq &gt;= 20 &amp;&amp; CenterFreq &lt;= 10099
      PathNum = 1;
    elseif CenterFreq &gt;= 10100 &amp;&amp; CenterFreq &lt;= 73999
      PathNum = 2;
    elseif CenterFreq &gt;= 74000 &amp;&amp; CenterFreq &lt;= 197499
      PathNum = 3;
    elseif CenterFreq &gt;= 197500 &amp;&amp; CenterFreq &lt;= 524999 
      PathNum = 4;
    elseif CenterFreq &gt;= 525000 &amp;&amp; CenterFreq &lt;= 1024998
      PathNum = 5;
    elseif CenterFreq &gt;= 1024999 &amp;&amp; CenterFreq &lt;= 1959998
      PathNum = 6;
    else
      % Freq not in range
      ItWorked = false;
    end
  case 'TNBL'
    if CenterFreq &gt;= 1959999 &amp;&amp; CenterFreq &lt;= 5829997
      PathNum = 7;
    elseif CenterFreq &gt;= 5829998 &amp;&amp; CenterFreq &lt;= 17329990
      PathNum = 8;
    elseif CenterFreq &gt;= 17329991 &amp;&amp; CenterFreq &lt;= 28729990
      PathNum = 9;
    elseif CenterFreq &gt;= 28729991 &amp;&amp; CenterFreq &lt;= 51729981
      PathNum = 10;
    elseif CenterFreq &gt;= 51729981 &amp;&amp; CenterFreq &lt;= 97829995
      PathNum = 11;
    elseif CenterFreq &gt;= 97829996 &amp;&amp; CenterFreq &lt;= 152329991
      PathNum = 12;
    elseif CenterFreq &gt;= 152329992 &amp;&amp; CenterFreq &lt;= 216329927
      PathNum = 13;
    elseif CenterFreq &gt;= 216329928 &amp;&amp; CenterFreq &lt;= 332229967
      PathNum = 14;
    elseif CenterFreq &gt;= 332229968 &amp;&amp; CenterFreq &lt;= 499999899
      PathNum = 15;
    elseif CenterFreq &gt;= 499999900 &amp;&amp; CenterFreq &lt;= 2009950080
      PathNum = 16;
    else
      ItWOrked = false;
    end
  otherwise
    % invalid filter type
    ItWorked = false;
end
if ItWorked
  [FiltType, FilterName, PathName, f1, f2, BW, Amp, G, NF, CompPt, ThrdOrd] = invoke(obj, 'PathPropertiesByPath', PathNum);
else
  FiltType = [];
  FilterName = [];
  PathName = [];
  f1 = [];
  f2 = [];
  BW = [];
  Amp = [];
  G = [];
  NF = [];
  CompPt = [];
  ThrdOrd = [];
  if RaiseError
    error('Presel:Function:UniversalPathProperties:InvalidInput',...
      'The input arguments do not correspond to a valid path. This function has not returned any values.');
  end
end</MCode>
               </Code>
               <Description>queries properties of the chosen path given the center freq and filter type</Description>
            </Method>
            <Method>
               <Name>iGenUniversalSetPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenUniversalSetPath(obj, FStart, FStop, FilterType, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
% create RaiseError and/or ChkResult variables if they are not input. False
% is the default for these variables.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

if ~exist('FilterType', 'var')
  FilterType = 'Not Needed';
end

ItWorked = true;
if strcmpi(FilterType, 'BYP') %bypass path
  set(obj, 'Bypass', 1)
  set(obj, 'IGenInputPort', 1)
  if RaiseError &amp;&amp; ChkResult
    check = get(obj, 'Bypass');
    check2 = get(obj, 'iGenInputPort');
    if check ~= 1 || check2 ~= 1
      error('Presel:Function:UniversalSetPath:SettingIncorrect',...
        'The preselector path has not been set as requested');
    end
  end
else % not Bypass path
  set(obj, 'Bypass', 0)
  if FStart &lt;= FStop &amp;&amp; FStart &gt;= 20 &amp;&amp; FStop &lt;= 2.2e9
    fprintf(interface, ['FA ',num2str(FStart),'Hz']);
    fprintf(interface, ['FB ',num2str(FStop),'Hz']);
    if RaiseError &amp;&amp; ChkResult
      checkStart = str2double(query(interface, 'FA?'));
      checkStop = str2double(query(interface, 'FB?'));
      if ~WithinTol(FStart, checkStart, 100, true) || ~WithinTol(FStop, checkStop, 100, true)
       error('Presel:Function:UniversalSetPath:SettingIncorrect',...
         'The preselector path has not been set as requested');
                %[num2str(FStart),' ',num2str(checkStart),' ',num2str(FStop),' ',num2str(checkStop),' ']);
      end
    end
  else % freqeuncy is not in range
    if RaiseError
      error('Presel:Function:UniversalSetPath:InvalidInput',...
        'The input parameters do not define a valid path. The path has not changed');
    end
  end
end</MCode>
               </Code>
               <Description>Sets the path using either the path number or center frequency.
This function is present so that measurements can use it to set the path by either freq or number with a single command.</Description>
            </Method>
            <Method>
               <Name>PathPropertiesByPath</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FilterType, FilterName, PathName, StartFreq, StopFreq, BandWidth, Amplifier, PathGain, NoiseFigure, CompressPt, ThrdOrdInt] = PathPropertiesByPath(obj, PathNum)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
switch PathNum
  case 0
    FilterType = 'BYP';
    FilterName = 'Bypass';
    PathName = 'Bypass (Ant Port 2 Only)';
    StartFreq = 0;
    StopFreq = 2.2e9;
    BandWidth = 2.2e9;
    Amplifier = 0;
    PathGain = 0;
    NoiseFigure = 0;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 1
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 20-10,099Hz';
    StartFreq = 20;
    StopFreq = 10099;
    BandWidth = 10079;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 2
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 10.1-74 kHz';
    StartFreq = 10100;
    StopFreq = 73999;
    BandWidth = 63899;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 3
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 74-123,500 kHz';
    StartFreq = 74000;
    StopFreq = 197499;
    BandWidth = 123499;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 4
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 197.5-525 kHz';
    StartFreq = 197500;
    StopFreq = 524999;
    BandWidth = 327499;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 5
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 525-1025 kHz';
    StartFreq = 525000;
    StopFreq = 1024998;
    BandWidth = 499998;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 6
    FilterType = 'BPF';
    FilterName = 'Band-pass';
    PathName = 'BP 1.025-1.96 MHz';
    StartFreq = 1024999;
    StopFreq = 1959997;
    BandWidth = 934998;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 7
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 1.96-5.83 MHz';
    StartFreq = 1959998;
    StopFreq = 5829997;
    BandWidth = 661300;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 8
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 5.83-17.33 MHz';
    StartFreq = 5829998;
    StopFreq = 17329990;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 9
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 17.33-28.73 MHz';
    StartFreq = 17329991;
    StopFreq = 28729990;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 10
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 28.73-51.73 MHz';
    StartFreq = 28729991;
    StopFreq = 51729981;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 11
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 51.73-97.83 MHz';
    StartFreq = 51729982;
    StopFreq = 97829995;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 12
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 97.83-152.33 MHz';
    StartFreq = 97829996;
    StopFreq = 152329991;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 13
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 152.33-216.33 MHz';
    StartFreq = 152329992;
    StopFreq = 216329927;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 14
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 216.33-332.23 MHz';
    StartFreq = 216329928;
    StopFreq = 332229967;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 15
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 332.23-500 MHz';
    StartFreq = 332229968;
    StopFreq = 499999899;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  case 16
    FilterType = 'TNBL';
    FilterName = 'Tunable YIG';
    PathName = 'TN 0.5-2 GHz';
    StartFreq = 499999900;
    StopFreq = 2009950080;
    BandWidth = StopFreq - StartFreq;
    Amplifier = 1;
    PathGain = 20;
    NoiseFigure = 15;
    CompressPt = 0;
    ThrdOrdInt = 0;
  otherwise
    FilterType = [];
    FilterName = [];
    PathName = [];
    StartFreq = [];
    StopFreq = [];
    BandWidth = [];
    Amplifier = [];
    PathGain = [];
    NoiseFigure = [];
    CompressPt = [];
    ThrdOrdInt = [];
    %Throw Warning invalid path number sent
end
    </MCode>
               </Code>
               <Description>' Returns path properties for the specified path indicated by the argument "PathNum".
'    The arguments returned are as follows:
'   1)  PathFilterType As String: this is the filter characteristic type.  The following Filter types are supported:
'         "None" = No Filter, Open Path
'         "BYP" = Straight Through coupled
'         "AUX" = Auxillary Path
'         "BPF" = Band pass Filter
'         "BRF" = Band Reject Filter
'         "LPF" = Low Pass Filter
'         "HPF" = High Pass Filter
'         "TNBL" = Tunable Filter
'   2)  StartFreq As Double:  this is the 3dB cutoff frequency (in Hz) for the lower end of a fixed filter's frequency band.
'                             For tunable filters, this is the Minimum tunable frequency.
'   3)  StopFreq As Double:  this is the 3dB cutoff frequency (in Hz) for the upper end of a fixed filter's frequency band.
'                             For tunable filters, this is the Maximum tunable frequency.
'   4)  Bandwidth As Double:  this is the 3 dB bandwidth (in Hz) of the narrowest filter in the path, be it a fixed
'         filter or a tunable filter. For a fixed filter the bandwidth is equal to (StopFreq - StartFreq)
'   5)  Amplifier As Integer:  indicates if an amplifier is included in the path. 0 = No Amplifier, 1 = Amplifier present
'   6)  PathGain:  this is the average gain (in dB) for the path EXCLUDING the attenuator.
'   7)  NoiseFigure:  this is the avereage Noise Figure in dBm for the path
'   8)  ByRef CompressPt As Single: this is the average 1-dB compression point (in dBm) for the path.
'   9)  ByRef ThrdOrdInt As Single: this is the average third-order intercept point (in dBm)
'         for the path.
' The argument "PathNum" designates the path for which the properties are requested, where the value
'   can be any value from 0 to (Number of paths).</Description>
            </Method>
            <Method>
               <Name>SetByFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function out = SetByFreq(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
out = true;</MCode>
               </Code>
               <Description>'Indicates whether the paths within the preselector are automatically set simply by sending a center
'  frequency (example HP85685 preselector).  The 3G and 4G preselectors paths are set by designating
'  a path, as appoosed to a center frequency
'false = path set by disignating the path
'true = path is set automatically by sending a center frequency</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>